<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Navigation system</title>
        <meta http-equiv='cache-control' content='no-cache'>
        <meta http-equiv='expires' content='0'>
        <meta http-equiv='pragma' content='no-cache'>
		<style>
			body { margin: 0; }
            .my-image {
              position: relative;
              top: -100px;
              left: 20px;
              height: 600px;
       }
       .my-image2 {
              position: relative;
              top: -100px;
              left: 45px;
              height: 600px;
       }
       #container {
  position: relative;
  width: 200px;
  height: 0px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 10px;
}
.label {
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 3px;
}
canvas {
  grid-column: 1 / span 2;
  grid-row: 1 / span 2;
}
		</style>
				<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
				<link type="text/css" rel="stylesheet" href="../static/main.css">
                <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
                <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script> <!--Add the dat.gui.js into the control-->
                <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
                <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css'>
                <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js'></script>
                <script src='https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js'></script>
                <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script> 
	</head>
	<body>
        <!--Get the data container of the project list and email account to check the hardware correctness -->
		<input type="hidden" id="project_payload" value="{{payload_project_list}}"> <!--Passing the project data from the link -->
        <input type="hidden" id ="component_nav" value="{{component_project}}">      
		<input type="hidden" id="video_frame" value="{{video_realtime}}">
       <!--
        <img id="image" class=".my-image" alt="Video Stream" style="width: 300px; height: 200px;">    
        <script type="text/javascript">
            setInterval(function() {
                   var data_container = document.getElementById('project_payload').value  //Get the payload navigation system 
                   //var data_com_nav   = document.getElelentById("component_nav").value //Get the component navigation system 
                   //console.log(data_container) 
                   var decode_account = atob(data_container)
                   var email_data = JSON.parse(decode_account)['email']   // Get the email data from account
                   var project_names = JSON.parse(decode_account)['project_name'] // Get the project name data 
                   document.getElementById("image").src = "../static/Real_time_image/"+project_names+"_"+email_data+".jpg?" + new Date().getTime();                   
                   //document.getElementById("image2").src = "../static/Real_time_image/no_signal.jpg?" + new Date().getTime();                    
                }, 75); 
        </script>
       -->
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
		<script type="text/javascript">
            var data_container = document.getElementById('project_payload').value  //Get the payload navigation system 
            //var data_com_nav   = document.getElelentById("component_nav").value //Get the component navigation system 
            //console.log(data_container) 
            var decode_account = atob(data_container);
            //console.log("Decoded_data ",decode_account); 
            //console.log(data_com_nav) 
           
                   // Define a matrix
            //var A = [[1, 2], [3, 4]];
            // Compute the determinant of the matrix using numeric.js 
            //var detA = numeric.det(A);
            // Print the result to the console
            //console.log("det(A) = " + detA);


        </script>
        <div id="container">
        <script type="module">
			import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.114.0/build/three.module.js';
            import { OrbitControls } from '../static/jsm/controls/OrbitControls.js';
			import { PCDLoader } from 'https://cdn.jsdelivr.net/npm/three@0.114.0/examples/jsm/loaders/PCDLoader.js';
			import {TrackballControls} from 'https://cdn.jsdelivr.net/npm/three@0.114.0/examples/jsm/controls/TrackballControls.js'
			import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.114.0/examples/jsm/loaders/GLTFLoader.js' 
            import { TextGeometry } from '../static/jsm/geometries/TextGeometry.js';
            import { RGBELoader } from '../static/jsm/loaders/RGBELoader.js'; //Loading the mesh rgb file 
            import { CSS2DRenderer, CSS2DObject } from '../static/jsm/renderers/CSS2DRenderer.js';
            import { GUI } from '../static/libs/lil-gui.module.min.js';
            
            //var data_container = document.getElementById('project_payload').value  //Get the payload navigation system 
            //var data_com_nav   = document.getElelentById("component_nav").value //Get the component navigation system 
            //console.log(data_container) 
            //console.log(data_com_nav)
            //console.log("Data_project_container ",data_container); 
            var email_data = JSON.parse(decode_account)['email']   // Get the email data from account
            var project_names = JSON.parse(decode_account)['project_name'] // Get the project name data 
            console.log(JSON.parse(decode_account))
            var current_robot = {} // Get the current robot hame on the project 
            var labelRenderer; //Get the labeler name 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //WiFi beacon navigation 
            var main_pos_signal = {}
            var indoor_signal_pos = {} //Get the navigation store 
            var type_navigation = {} 
            var methods_navigation = {}
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            var data_wifi_localization = {} 
            var navigation_code_gen = {} // Mem the features of the navigation code to generate the code into the hardware 
            var feature_add_nav = {} // Add the nav features data 
            var payload_navigation = {} // Get the payload navigation system 
            var project_nav_name = {} //Navigation system project nav name store 
            var local_nav_name = {} 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input camera nav component data of the function 
            var input_cam_pos = {} 
            var input_cam_nav_com = {} 
            var input_cam_nav_type = {} 
            var camera_navigationmap = {} 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input lidar nav component data of the function 
            var outdoor_lidar_pos = {} // This lidar can be update upto the position of the 3D model position data 
            var input_lidar_nav_com = {} 
            var input_lidar_nav_type = {} 
            var lidar_navigationmap = {}  
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input GPS nav component data of the function 
            var outdoor_gps_pos = {} 
            var input_gps_nav_com = {} 
            var input_gps_nav_type = {} 
            var gps_navigationmap = {} 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input point_cloud_camera data of the function 
            var outdoor_pcd_pos = {} 
            var input_pcd_nav_com = {} 
            var input_pcd_nav_type = {} 
            var pcd_navigationmap = {} 
            
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input optic flow mapping navigation system data 
            var outdoor_opticflow_pos = {} 
            var input_opticflow_com = {} 
            var input_optic_nav_type = {} 
            var opticflow_navigationmap = {} 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Input cellular network navigation system to track the navigation from the GPRS cellular module to send the accurate position of the robot 
            var outdoor_cellular_pos = {} 
            var input_cellular_com = {} 
            var input_cellular_type = {} 
            var cellular_navigation_map = {} 
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            
            //Lidar data of the point cloud for the visualizer 
            var lidar_data_pcd = {}  // Get the local pcd data of the visualizer 
            var lidar_array_pcd = [] // Test 1 lidar array scanner function 
            //The variable to get the data of the current 
            var access_point_pos = {} // Get the access point data 
            var access_local_trilation = {} // Get the position of the update coordinate trilation 

            var settings_mobile_signal = {} //Mark the mobile robot data of the signal position 
            var list_wifi_components = {} // Get the list of the wifi and count if there are equal or more than 3 then using this to gain the data of the position and update via chaging RSSI real-time data 
            var dynamic_status = {}  // Get the dyanmic data status 
            var lidar_position_label = {} // Get the position for the label experiment position test function  
            var labelRenderer;
            var models = {}; 
            const gridExtensionFactor = 1.5; 
            var  MOON_RADIUS = 0.27;
            //Fetch the project component list to check the navigation system 
            // POST
            try{
            fetch('/request_nav_com', {
                 // Declare what type of data we're sending
                 headers: {
                       'Content-Type': 'application/json'
                },
                // Specify the method 
                method: 'POST',
               // A JSON payload 
               body: JSON.stringify(JSON.parse(decode_account))
               }).then(function (response) { // At this point, Flask has printed our JSON
               return response.text();
               }).then(function (text) {
               console.log('POST response: ');

                // Should be 'OK' if everything was successful
                var component_nav_payload = JSON.parse(text);
                if(Object.keys(component_nav_payload)[0] != 'status'){
                    console.log("Feedback_payload",component_nav_payload);
                }
                if(Object.keys(component_nav_payload)[0] == 'status'){
                    console.log("Components feedback data not found");
                    notify_data('warning','No single board computer or onboard computer feedback data found')
                }  
                
            }); 
        }
        catch{
             console.log("Navigation component not found");
        }

        
            fetch('/project_file_match', {
                 // Declare what type of data we're sending
                 headers: {
                       'Content-Type': 'application/json'
                },
                // Specify the method 
                method: 'POST',
               // A JSON payload 
               body: JSON.stringify(JSON.parse(decode_account))
               }).then(function (response) { // At this point, Flask has printed our JSON
               return response.text();
               }).then(function (text) {
               console.log('POST response: ');
                // Should be 'OK' if everything was successful
                var component_nav_payload = JSON.parse(text);
                console.log("Model_name_file",component_nav_payload);
                if(Object.keys(component_nav_payload)[0] != 'status'){
                   console.log(component_nav_payload[project_names]);
                   current_robot["current_robot"] = project_names
                   notify_data('success',project_names+" retrieved data successfully!")
                }
                if(Object.keys(component_nav_payload)[0] == "status"){
                    console.log("You haven't create any project"); 
                    notify_data('warning',"You haven't create any project please create your project");
                }
            });          
            
            var settings ={}
            var control_logic_function = {}; 
            //Get the data from the
            var gui = new dat.GUI({autoPlace: true});
            settings["camera_tracker"] = false; 
            settings["first_person"] = false; 
            settings["pcd_timing"] = 1;  
            settings['dynamic_mot'] = false           
            var camera_track = gui.addFolder("Camera_sync_settings")
            var cam_controller = camera_track.add(settings,"camera_tracker").name("Orbit_camera")
            cam_controller.onChange(function(value_cam){
                       console.log("Cam_control_logic",value_cam); // Get the value from the camera controller
                       control_logic_function['orbit_cam_logic'] = value_cam; //get the orbit camera logic control function     
            });
            //Get the fps camera tracking function 
            var fps_cam =camera_track.add(settings,"first_person").name("FPS_camera")
            fps_cam.onChange(function(fps_value){
                       console.log("FPS_cam_logic",fps_value); 
                       control_logic_function['fps_cam_logic'] = fps_value; //Get the first person logic      
            })
            settings['cam_fol_track'] = false  //se
            var cam_path_fol = camera_track.add(settings,"cam_fol_track").name("Follow_cam")
            cam_path_fol.onChange(function(value_cam_fol){
                       console.log("Follow camera ",value_cam_fol); 
                       control_logic_function['follow_cam'] = value_cam_fol; 
            });
            var dynamic_mod = camera_track.add(settings,"dynamic_mot").name("Continues map"); 
            dynamic_mod.onChange(function(value_dynamap){
                            console.log(value_dynamap); // Get the dynamic map data from the checkout 
                            dynamic_status['status_data'] = value_dynamap;  
            }); //Get the dynamic map data 
            var pcd_time = camera_track.add(settings,"pcd_timing",1,3000).name("PCD_scan_time") 
            pcd_time.setValue(1000)
            pcd_time.onChange(function(time_values){
                       console.log("PCD_timing_control",time_values); 
                       control_logic_function['pcd_timing'] = parseInt(time_values);  
            });
            
            settings['color'] = 0xffffff
            var cpath_line = gui.addFolder("Path line axis settings") 
            var color_line = cpath_line.addColor(settings,"color").name("Line color") 
            color_line.onChange(function(color_value){
                          console.log("Line color ",color_value); // Get the color value
                          control_logic_function['color_line'] = color_value 

            });
           
            settings['axes']  = false
            var axes_path = cpath_line.add(settings,"axes").name("Axes enable")
            //axes_path.setValue(true); 
            axes_path.onChange(function(value_axes){
                         console.log("Add axes into the path ",value_axes); 
                         control_logic_function['Axes_path'] = value_axes; 
            })
             
            settings['proc_path'] = false 
            var rand_path = cpath_line.add(settings,"proc_path").name("Programming path") 
            rand_path.onChange(function(value_rand){
                              console.log("Programming_path",value_rand); 
                              control_logic_function['proc_paths'] = value_rand; 
            })            
            settings['real_rand_path'] = false 
            var rand_real = cpath_line.add(settings,"real_rand_path").name("Random_path") 
            rand_real.onChange(function(value_rand){
                        console.log("Random_path ",value_rand); 
                        control_logic_function['real_rand_path'] = value_rand;     
            });
            settings['sensor_sync'] = false 
            var hardware_sync = cpath_line.add(settings,"sensor_sync").name("Sync_Robot")  
            hardware_sync.onChange(function(value_sensor){
                        console.log("Hardware sync enable ",value_sensor);
                        control_logic_function["sensor_sync"] = value_sensor

            })
         
            // Get the swarm mode function 
            settings['swarm_mode'] = false 
            var swarm_modes = cpath_line.add(settings,"swarm_mode").name("Swarm_mode")
            swarm_modes.onChange(function(value_swarm_mode){
                        console.log("Swarm modes ", value_swarm_mode); 
                        control_logic_function['swarm_mode'] = value_swarm_mode;  

            });
            // Mark the position of the domes and the rssi visualization data
             
            settings['indoor_beacon'] = function(){
                                  console.log("Active add the WiFi beacon marker");    
                                  console.log("Activate the indoor WiFi beacon navigation ")
                                  var raycaster = new THREE.Raycaster();
                                  var mouse = new THREE.Vector2();
                                  renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
                                  function onDocumentMouseDown(event) {
                                                       // Calculate mouse position in normalized device coordinates
                                                        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                                                        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                                                        console.log("Mouse click position ",mouse.x,mouse.y); 
                                    
                                                        raycaster.setFromCamera(mouse,camera);
                                                        var position_mouse = {"x":mouse.x,"y":mouse.y} 
                                                        var intersects = raycaster.intersectObjects([grid]);
                                                        console.log(intersects); 
                                                        var h = 1; 
                                                        //Add the dynamic loop of the 
                                                        var geometrys = new THREE.SphereGeometry(2, 32, 32, -Math.PI/2, Math.PI);
                                                        // Create a material for the dome with a transparent color and an initial opacity of 0.5
                                                        //var materials = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                                                        const materials = new THREE.MeshPhysicalMaterial({ 
                                                             color: 0xffffff, 
                                                             transparent: true,
                                                             opacity: 0.2,
                                                             roughness: 0.1,
                                                             metalness: 0.4,
                                                        });
                                                        // Create a mesh using the geometry and material
                                                        var domes_wifi = new THREE.Mesh(geometrys, materials);
                                                        domes_wifi.position.set(10,h,-10); // Add the  x,z,y 
                                                        // Add the dome to the scene
                                                        domes_wifi.rotation.z = 270*Math.PI/180
                                                        scene.add(domes_wifi);
                                                        // Adjust the opacity of the material 
                                                        materials.opacity = 0.8;
                                                        
                                                       
                                }   

            }
            settings['indoor_ble'] = function(){
                           console.log("Actie add the BLE beacon marker");
                           console.log("Activate the  BLE beacon navigation ")
                                  var raycaster = new THREE.Raycaster();
                                  var mouse = new THREE.Vector2();
                                  renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
                                  function onDocumentMouseDown(event) {
                                                       // Calculate mouse position in normalized device coordinates
                                                       /*
                                                        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                                                        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                                                        console.log("Mouse click position ",mouse.x,mouse.y); 
                                    
                                                        raycaster.setFromCamera(mouse,camera);
                                                        var position_mouse = {"x":mouse.x,"y":mouse.y}
                                                        */ 
                                                        var intersects = raycaster.intersectObjects([grid]);
                                                        console.log(intersects); 
                                                        var h = 1; 
                                                        var geometrys = new THREE.SphereGeometry(2, 32, 32, -Math.PI/2, Math.PI);
                                                        // Create a material for the dome with a transparent color and an initial opacity of 0.5
                                                        //var materials = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                                                        const materials = new THREE.MeshPhysicalMaterial({ 
                                                             color: 0xffffff, 
                                                             transparent: true,
                                                             opacity: 0.2,
                                                             roughness: 0.1,
                                                             metalness: 0.4,
                                                        });
                                                        // Create a mesh using the geometry and material
                                                        var domes_wifi = new THREE.Mesh(geometrys, materials);
                                                        domes_wifi.position.set(-10,h,-10); 
                                                        // Add the dome to the scene
                                                        domes_wifi.rotation.z = 270*Math.PI/180
                                                        scene.add(domes_wifi);
                                                        // Adjust the opacity of the material 
                                                        materials.opacity = 0.8;
                                                    
                                                       
                                }
            }
            settings['generate_signal_pos'] = function(){
                              console.log("Generate signal positioning");
                              console.log("Positioning generated",main_pos_signal);
                              console.log("Wifi mobile localization data ",settings_mobile_signal);   
                              console.log("Lidar mapping data ",lidar_navigationmap) 
            }
            settings['select_beacon'] = function(){ 
                             
                          //navigation.removeFolder(nav_id); 
                          var root_json = gui.getSaveObject();
                          console.log("Folder branch data",root_json); 
                          var check_nav_list = root_json['folders']['Navigation_components_position_settings']
                          console.log("Check_settings ",check_nav_list)
                          //Checking the older list in json then remove it 
                          /*
                          var check_nav_list = root_json['folders']['Navigation_components_position_settings']
                          console.log("Root json data ", root_json); 
                          console.log("Seek inner folder ", check_nav_list); 
                          var folder_nav_list = check_nav_list['folders']
             
                          console.log("Folder_data_inner ",folder_nav_list); 
                          */
                          //console.log("Name for generated navigation ",settings['nav_name']); // Setting the data of the 
                          //var name_navigation = settings['nav_name'];
                          //Check of the navigation component generated inside the list 
                         // console.log("Navigation component input ",name_navigation);
                         settings['Select_nav_compo'] = "";  
                         fetch('/Nav_com_checklist', {

                              // Declare what type of data we're sending
                              headers: {
                                        'Content-Type': 'application/json'
                              },

                                // Specify the method
                              method: 'POST',
                              // A JSON payload
                             body: JSON.stringify({
                                       "email": email_data
                             })
                          }).then(function (response) { // At this point, Flask has printed our JSON
                          return response.text();
                          }).then(function (text) {
                           console.log('POST response: ');
                             // Should be 'OK' if everything was successful
                                 
                                 var check_list_data = JSON.parse(text);
                                 if(check_list_data != {}){
                                         console.log("Check list data ",check_list_data);
                                         var host_name = Object.keys(check_list_data['navigation_payload']); 
                                         var main_check_list = check_list_data['navigation_payload'][host_name][project_names]
                                         console.log(main_check_list)
                                         var list_options_nav = Object.keys(main_check_list); //Get the main check list of the navigation component htat has been created on the navigation system 
                                         list_options_nav.unshift("Non-selected");       
                                         var option_nav_select = navigation.add(settings,"Select_nav_compo",list_options_nav).name("Navigation_select") 
                                         option_nav_select.setValue("Non-selected")
                                         option_nav_select.onChange(function(value_nav_op){
                                                        console.log("Component_navigation_selected ",value_nav_op); 
                                                        //Check the navigation component type data to choose the base option selected to deploy system on board 
                                                        console.log("Navigation function ",main_check_list[value_nav_op])   //Get the data of the option navigation type data          
                                                        local_nav_name['nav_name'] = value_nav_op
                                                        var value_nav_indoor =main_check_list[value_nav_op]['Navigation_component'];
                                                        var value_dat_nav = main_check_list[value_nav_op]['Navigation_type']; 
                                                        console.log("Component data navigation ",value_nav_indoor);
                                                        var nav_sys = navigation.addFolder(value_nav_op); //Get the navigation system folder for settings 
                                                        
                                                        if(value_nav_indoor == 'Beacon_WiFi_navigation'){
                                                                   //Add the parameters of the function into the scene 
                                                                   settings['param_x'] = 0.0;
                                                                   settings['param_y'] = 0.0;
                                                                   settings['param_z'] = 0.0; 
                                                                   settings['wifi_mobile'] = false; 
                                                                   //Setting the data of the selected mobile signal for calculation in trilation algorithm 
                                                                   var set_mobile_wifi = nav_sys.add(settings,"wifi_mobile").name("Robot_WiFi");
                                                                   set_mobile_wifi.onChange(function(value_mobile_wifi){
                                                                                console.log("Wifi mobile localization setmain",value_mobile_wifi); // Get the mobile wifi data name in the list 
                                                                                settings_mobile_signal[value_nav_op] = value_mobile_wifi; // Get the wifi mobile marker status to check detect if the  marker is selected                                                
                                                                   });  
                                                                   var param_x_pos = nav_sys.add(settings,"param_x",-3000.0,3000.0).name("x-position"); 
                                                                   param_x_pos.onChange(function(value_param_x){
                                                                    
                                                                                    indoor_signal_pos['x'] = value_param_x;    

                                                                   });
                                                                   var param_y_pos = nav_sys.add(settings,"param_y",-3000.0,3000.0).name("y-position"); 
                                                                   param_y_pos.onChange(function(value_param_y){

                                                                                     indoor_signal_pos['y'] = value_param_y;
                                                                                      
                                                                   })        
                                                                   var param_z_pos = nav_sys.add(settings,"param_z",-3000.0,3000.0).name("z-position"); 
                                                                   param_z_pos.onChange(function(value_param_z){

                                                                                     indoor_signal_pos['z'] = value_param_z;

                                                                   })
                                                                   //Dome color setting parameters 
                                                                   settings['dome_color'] = 0xea0000  // Set the dome color in red color 
                                                                   var dome_color = nav_sys.addColor(settings,"dome_color").name("Color_dome") 
                                                                   dome_color.setValue(0xea0000);
                                                                   dome_color.onChange(function(value_color_dome){
                                                                               console.log("Data_value_dome ",value_color_dome);   
                                                                               indoor_signal_pos['colorize_dome'] = value_color_dome
                                                                               
                                                                   });
                                                                   settings['color_label'] = 0xea0000 
                                                                   var label_text_color = nav_sys.addColor(settings,"color_label").name("Color label"); 
                                                                   label_text_color.onChange(function(value_color_text){
                                                                               console.log("Data color text label ",value_color_text); //Get the label color text to display the data of the indoor navigation system 
                                                                               
                                                                   });
                                                                
                                                                   methods_navigation[value_nav_indoor] = indoor_signal_pos 
                                                                   type_navigation[value_dat_nav] = methods_navigation                                                                                              
                                                                   main_pos_signal[local_nav_name['nav_name']] = type_navigation
                                                                   var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com")
                                                                   add_signal_pos.onChange(function(value_logic){
                                                                                    //select_nav_type.remove()
                                                                                    
                                                                                    console.log(local_nav_name)
                                                                                    //Remove the old folder too and it will not interrupt the click position on the dat.gui.js 
                                                                                    //Remove only the case it's not the blank dict value 
                                                                                
                                                                   })
                                                                
                                                                   //Change the color of the the dome and the label text 
                                                                   

                                                                    
                                                         } 
                                                         if(value_nav_indoor == 'Beacon_BLE_navigation'){
                                                             
                                                             settings['param_x'] = 0.0;
                                                             settings['param_y'] = 0.0;
                                                             settings['param_z'] = 0.0; 
                                                             var param_x_pos = nav_id.add(settings,"param_x",-3000.0,3000.0).name("x-position"); 
                                                             var param_y_pos = nav_id.add(settings,"param_y",-3000.0,3000.0).name("y-position");         
                                                             var param_z_pos = nav_id.add(settings,"param_z",-3000.0,3000.0).name("z-position");

                                                             param_x_pos.onChange(function(value_param_x){
                                                                               indoor_signal_pos['x'] = value_param_x;           
                                                             });
                                                             var param_y_pos = nav_id.add(settings,"param_y",-3000.0,3000.0).name("y-position"); 
                                                             param_y_pos.onChange(function(value_param_y){
                                                                               indoor_signal_pos['y'] = value_param_y
                                                             })        
                                                             var param_z_pos = nav_id.add(settings,"param_z",-3000.0,3000.0).name("z-position"); 
                                                             param_z_pos.onChange(function(value_param_z){
                                                                               indoor_signal_pos['z'] = value_param_z
                                                             })
                                                             methods_navigation[value_nav_indoor] = indoor_signal_pos                                                                            
                                                             type_navigation[value_dat_nav] = methods_navigation
                                                             main_pos_signal[name_navigation]  = type_navigation
                                                             var add_signal_pos = nav_id.add(settings,"generate_signal_pos").namve("Add nav com")      
                                                         }
                                                         settings['Camera_statement'] = true;  // setting the camera status to setting statement of the camera

                                                         if(value_nav_indoor == 'Camera_navigation'){
                                                                     //console.log("Adding the camerausing in the QR code tracking")          
                                                                     settings['camera_nav_x'] = 0.0; 
                                                                     settings['camera_nav_y'] = 0.0; 
                                                                     settings['camera_nav_z'] = 0.0; 
                                                                     settings['camera_color'] = 0x12ed00; 
                                                                     settings['camera_text_color'] = 0x12ed00; 
                                                                     var cam_param_x = nav_sys.add(settings,"camera_nav_x",-3000.0,3000.0).name("x-position")
                                                                     cam_param_x.onChange(function(x_value){
                                                                                     console.log("camera-x ",x_value); 
                                                                                     input_cam_pos['x'] = x_value; 
                                                                     }); 
                                                                     var cam_param_y = nav_sys.add(settings,"camera_nav_y",-3000.0,3000.0).name("y-position"); 
                                                                     cam_param_y.onChange(function(y_value){
                                                                                     console.log("camera-y ",y_value);
                                                                                     input_cam_pos['y'] = y_value;  
                                                                     });
                                                                     var cam_param_z = nav_sys.add(settings,"camera_nav_z",-3000.0,3000.0).name("z-position"); 
                                                                     cam_param_z.onChange(function(z_value){
                                                                                     console.log("camera-z ",z_value)
                                                                                     input_cam_pos['z'] = z_value; 

                                                                     });
                                                                     settings['Camera_statement'] = true;  // setting the camera status to setting statement of the camera
                                                                     settings["camera_set_nav"] = ""; // Setting the camera position  
                                                                     var list_pos_select = ['Front','Side','Top']
                                                                     var angle_set_view = {"Front":{'z':90},"Side":{'x':90},"Top":{'y':90}}
                                                                     list_pos_select.unshift("Non-selected"); 
                                                                     var camera_position_set = nav_sys.add(settings,"camera_set_nav",list_pos_select).name("Cam_view") //Select the camera view 
                                                                     camera_position_set.setValue("Non-selected"); 
                                                                     camera_position_set.onChange(function(value_view_data){
                                                                                    console.log("Camera_view_data ",value_view_data); //Get the camera data of the view angle on each cam to detect robots in the scene 
                                                                                    input_cam_pos['view_pos'] =value_view_data;  //Get the position of the camera view                                       
                                                                     });
                                                                     settings['camera_px'] = 0.0;
                                                                     settings['camera_py'] = 0.0; 
                                                                     settings['Area_x'] = 0.0;
                                                                     settings['Area_y'] = 0.0; 
                                                                     var camera_px_view = nav_sys.add(settings,"camera_px",-3000.0,3000.0).name("px_cam")
                                                                     camera_px_view.onChange(function(value_px){
                                                                                   console.log("Camera_px_value ",value_px);
                                                                                   input_cam_pos['cam_px'] = value_px;
                                                                     }) 
                                                                     var camera_py_view = nav_sys.add(settings,"camera_px",-3000.0,3000.0).name("py_cam") 
                                                                     camera_py_view.onChange(function(value_py){
                                                                                   console.log("Camera_py ",value_py);
                                                                                   input_cam_pos['cam_py'] = value_py;                 
                                                                     });

                                                                     var Area_view_x = nav_sys.add(settings,"Area_x",-3000.0,3000.0).name("Area_x")  
                                                                     Area_view_x.onChange(function(value_area_x){
                                                                                    console.log("Camera_area_X",value_area_x);
                                                                                    input_cam_pos["area_x"] = value_area_x;  
                                                                     }) 
                                                                     var Area_view_y = nav_sys.add(settings,"Area_y",-3000.0,3000.0).name("Area_y")
                                                                     Area_view_y.onChange(function(value_area_y){
                                                                                    console.log("Camera_area_Y",value_area_y); 
                                                                                    input_cam_pos["area_y"] = value_area_y;
                                                                     });

                                                                     var camera_color = nav_sys.addColor(settings,"camera_color").name("Camera_color")
                                                                     camera_color.onChange(function(camera_color_vav){
                                                                                     console.log("Camera_color ",camera_color_vav);
                                                                                     input_cam_pos['Camera_color'] = camera_color_vav; //Get the camera color data                 
                                                                     });
                                                                     var camera_text = nav_sys.addColor(settings,"camera_text_color").name("text_color")
                                                                     camera_text.onChange(function(value_text_color){
                                                                                     console.log("camera text color data",value_text_color) 
                                                                                     input_cam_pos["camera_text_color"] = value_text_color
                                                                     });
                                                                     input_cam_nav_com[value_nav_indoor] = input_cam_pos
                                                                     input_cam_nav_type[value_dat_nav] = input_cam_nav_com 
                                                                     camera_navigationmap[local_nav_name['nav_name']] = input_cam_nav_type 
                                                                     var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com")
                                                                     add_signal_pos.onChange(function(value_logic){
                                                                                    //select_nav_type.remove()

                                                                                    console.log(local_nav_name)
                                                                                    //Remove the old folder too and it will not interrupt the click position on the dat.gui.js
                                                                                    //Remove only the case it's not the blank dict value

                                                                   })

                                                         }
                                                         if(value_nav_indoor == 'Lidar'){
                                                             
                                                             settings['param_lidar_x'] = 0.0;
                                                             settings['param_lidar_y'] = 0.0;
                                                             settings['param_lidar_z'] = 0.0; 
                                                             settings['lidar_dyna_pos'] = false; 
                                                             settings['lidar_color_pcd'] = 0xff0000; // Get the point cloud color data
                                                             var param_lidar_x_pos = nav_sys.add(settings,"param_lidar_x",-3000.0,3000.0).name("x-position"); 
                                                             var param_lidar_y_pos = nav_sys.add(settings,"param_lidar_y",-3000.0,3000.0).name("y-position");         
                                                             var param_lidar_z_pos = nav_sys.add(settings,"param_lidar_z",-3000.0,3000.0).name("z-position");
                                                             var lidar_color = nav_sys.addColor(settings,"lidar_color_pcd").name("point_cloud_color"); // Get the lidar color 
                                                             lidar_color.onChange(function(value_lidar_color){
                                                                                outdoor_lidar_pos['lidar_pcd_color'] = value_lidar_color; // Get the lidar pcd color  
                                                             })
                                                             
                                                             var dyna_pos_data  = nav_sys.add(settings,"lidar_dyna_pos").name("dynamic_mode"); 
                                                             dyna_pos_data.onChange(function(value_dyna_lidar){
                                                                                 outdoor_lidar_pos['lidar_state'] = value_dyna_lidar; // Get the dynamic data of the status 
                                                             }) 
                                                             param_lidar_x_pos.onChange(function(value_param_x){
                                                                               outdoor_lidar_pos['x'] = value_param_x;           
                                                             }); 
                                                             param_lidar_y_pos.onChange(function(value_param_y){
                                                                               outdoor_lidar_pos['y'] = value_param_y
                                                             })        
                                                             param_lidar_z_pos.onChange(function(value_param_z){
                                                                               outdoor_lidar_pos['z'] = value_param_z
                                                             })
                                                             //Setting the function of the lidar to input the function of the mapping navgiation add into the scene 
                                                             //Noted that this lidar position will be updated over time when the robot is moving in the scene 

                                                             input_lidar_nav_com[value_nav_indoor] = outdoor_lidar_pos                                                                            
                                                             input_lidar_nav_type[value_dat_nav] = input_lidar_nav_com
                                                             lidar_navigationmap[local_nav_name]  = input_lidar_nav_type
                                                             var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com") // Add the function 
                                                                   
                                                         }
                                                         if(value_nav_indoor == 'GPS'){
                                                             
                                                             settings['param_GPS_x'] = 0.0;
                                                             settings['param_GPS_y'] = 0.0;
                                                             settings['param_GPS_z'] = 0.0; 
                                                             var param_gps_x_pos = nav_sys.add(settings,"param_GPS_x",-3000.0,3000.0).name("x-position"); 
                                                             var param_gps_y_pos = nav_sys.add(settings,"param_GPS_y",-3000.0,3000.0).name("y-position");         
                                                             var param_gps_z_pos = nav_sys.add(settings,"param_GPS_z",-3000.0,3000.0).name("z-position");

                                                             param_gps_x_pos.onChange(function(value_param_x){
                                                                               outdoor_gps_pos['x'] = value_param_x;           
                                                             }); 
                                                             param_gps_y_pos.onChange(function(value_param_y){
                                                                               outdoor_gps_pos['y'] = value_param_y
                                                             })        
                                                             param_gps_z_pos.onChange(function(value_param_z){
                                                                               outdoor_gps_pos['z'] = value_param_z
                                                             })
                                                             //Setting the function of the lidar to input the function of the mapping navgiation add into the scene 
                                                             //Noted that this lidar position will be updated over time when the robot is moving in the scene 

                                                             input_gps_nav_com[value_nav_indoor] = outdoor_gps_pos                                                                            
                                                             input_gps_nav_type[value_dat_nav] = input_gps_nav_com
                                                             gps_navigationmap[local_nav_name]  = input_gps_nav_type
                                                             var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com") // Add the function 
                                                                   
                                                         }
                                                         if(value_nav_indoor == 'Cellular'){
                                                             
                                                             settings['param_cellular_x'] = 0.0;
                                                             settings['param_cellular_y'] = 0.0;
                                                             settings['param_cellular_z'] = 0.0; 
                                                             var param_cellular_x_pos = nav_sys.add(settings,"param_cellular_x",-3000.0,3000.0).name("x-position"); 
                                                             var param_cellular_y_pos = nav_sys.add(settings,"param_cellular_y",-3000.0,3000.0).name("y-position");         
                                                             var param_cellular_z_pos = nav_sys.add(settings,"param_cellular_z",-3000.0,3000.0).name("z-position");

                                                             param_cellular_x_pos.onChange(function(value_param_x){
                                                                               outdoor_cellular_pos['x'] = value_param_x;           
                                                             }); 
                                                             param_cellular_y_pos.onChange(function(value_param_y){
                                                                               outdoor_cellular_pos['y'] = value_param_y
                                                             })        
                                                             param_cellular_z_pos.onChange(function(value_param_z){
                                                                               outdoor_cellular_pos['z'] = value_param_z
                                                             })
                                                              //Setting the function of the lidar to input the function of the mapping navgiation add into the scene 
                                                             //Noted that this lidar position will be updated over time when the robot is moving in the scene 

                                                             input_cellular_nav_com[value_nav_indoor] = outdoor_cellular_pos                                                                            
                                                             input_cellular_nav_type[value_dat_nav] = input_cellular_nav_com
                                                             cellular_navigationmap[local_nav_name]  = input_cellular_nav_type
                                                             var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com") // Add the function 
                                                                   
                                                         }
                                                         if(value_nav_indoor == 'point_cloud_3D'){
                                                             
                                                             settings['param_pcd_x'] = 0.0;
                                                             settings['param_pcd_y'] = 0.0;
                                                             settings['param_pcd_z'] = 0.0; 
                                                             var param_pcd_x_pos = nav_sys.add(settings,"param_pcd_x",-3000.0,3000.0).name("x-position"); 
                                                             var param_pcd_y_pos = nav_sys.add(settings,"param_pcd_y",-3000.0,3000.0).name("y-position");         
                                                             var param_pcd_z_pos = nav_sys.add(settings,"param_cpd_z",-3000.0,3000.0).name("z-position");

                                                             param_pcd_x_pos.onChange(function(value_param_x){
                                                                               outdoor_pcd_pos['x'] = value_param_x;           
                                                             }); 
                                                             param_pcd_y_pos.onChange(function(value_param_y){
                                                                               outdoor_pcd_pos['y'] = value_param_y
                                                             })        
                                                             param_pcd_z_pos.onChange(function(value_param_z){
                                                                               outdoor_pcd_pos['z'] = value_param_z
                                                             })
                                                             //Setting the function of the lidar to input the function of the mapping navgiation add into the scene 
                                                             //Noted that this lidar position will be updated over time when the robot is moving in the scene 

                                                             input_pcd_nav_com[value_nav_indoor] = outdoor_pcd_pos                                                                            
                                                             input_pcd_nav_type[value_dat_nav] = input_pcd_nav_com
                                                             pcd_navigationmap[local_nav_name]  = input_pcd_nav_type
                                                             var add_signal_pos = nav_sys.add(settings,"generate_signal_pos").name("Add nav com") // Add the function 
                                                                   
                                                         }
                                                                                                                 

                                                         


                                                    
                                         });
                                 
                                } 
                                 if(check_list_data == {}){
                                        alert("You are heven't create navigation components!"); 
                                 }

                          });
                                                   
            };
     
            //var navigation = gui.addFolder("Navigation_components_position_settings")
           
            //var add_beacon = navigation.add(settings,"select_beacon").name("Select Navigation type")

            
            //navigation.open()
           try{
            //All your robotics networking 
            fetch('/Navigation_mesh_swarm', {
                                   // Declare what type of data we're sending
                                   headers: {
                                       'Content-Type': 'application/json'
                                   },
                                  // Specify the method
                                 method: 'POST',
                                 // A JSON payload
                                 body: JSON.stringify({"email":email_data
                            })
                          }).then(function (response) { // At this point, Flask has printed our JSON
                          return response.text();
                          }).then(function (text) {
                                  console.log('POST response: ');
                                  // Should be 'OK' if everything was successful 
                                  var mesh_swarm = JSON.parse(text);
                                  //Get the mesh swarm feature to running the swarm of the robot in the loop  
                                  console.log(mesh_swarm); //Get the data of the mesh swarm to running in the loop 
                                  //Read the swarm bot name in user fleet robot
                                if(Object.keys(mesh_swarm)[0] != "status"){  
                                if(mesh_swarm != {}){  
                                  settings['list_active'] = ""; 
                                  var active_current = Object.keys(mesh_swarm)
                                  console.log("Get active current robot",active_current)
                                  active_current.unshift("Non-select")
                                  var active_folder  = gui.addFolder("Active swarm list config")
                                  var active_network_robot = active_folder.add(settings,"list_active",active_current).name("Active swarm list")
                                   //Get the function of the active current robot data to be able to configure the color and mission 
                                  active_network_robot.setValue("Non-select"); 
                                   
                                  active_network_robot.onChange(function(value_network_swarm){
                                                console.log("Get the selected active robot from the list ",value_network_swarm); 
                                                //Show the setting list of the path
                                                var swarm_color_mark = active_folder.addFolder(value_network_swarm) 
                                                settings["color_swarm"] = 0xea0000
                                                var color_text_swarm = swarm_color_mark.addColor(settings,"color_swarm").name("Color_"+value_network_swarm); 
                                                color_text_swarm.setValue(0xea0000)
                                                color_text_swarm.onChange(function(value_swarm_color){
                                                                console.log("Swarm text color mark ",value_swarm_color); 
                                                                control_logic_function[value_network_swarm] = value_swarm_color ; //Save the color mark of the swarm color 
                                                                console.log(control_logic_function[value_network_swarm]) 
                              
                                                })
                                                settings["pathc_swarm"] = 0xf9efef
                                                var color_path_swarm = swarm_color_mark.addColor(settings,"pathc_swarm").name("Path_color_swarm"); 
                                                color_path_swarm.setValue(0xf9efef)
                                                color_path_swarm.onChange(function(value_swarm_color){
                                                                console.log("Swarm path color mark ",value_swarm_color); 
                                                                control_logic_function[value_network_swarm+"_pathc"] = value_swarm_color ; //Save the color mark of the swarm color 
                                                                console.log(control_logic_function[value_network_swarm+"_pathc"]) 
                              
                                                })
                                                

                                  })

                                  active_folder.open();
                               }  
                            }
                            if(Object.keys(mesh_swarm) == "status"){
                                 console.log("Mesh Swarm data is not exist due to project haven't been created");
                            }
                                  
                                     
            });
        }
        catch{
              console.log("No device found connect with the swarm connection");
        }
            //Randomly create the color mark for the swarm 
           
            /*
            var text_label = gui.addFolder("Text label settings")
            settings['text_color'] = 0x13bcbc 
            var text_color = text_label.addColor(settings,"text_color").name("Text_color");
            text_color.onChange(function(value_color_text){
                       console.log("Text label color ",value_color_text); 
                       control_logic_function['text_color'] = value_color_text;
;  
            }) 
            settings['text_sizes'] = 0
            var text_size  = text_label.add(settings,"text_sizes",0.0,5).name("Text_size");
            text_size.setValue(0); 
            text_size.onChange(function(value_size_text){
                             console.log("Text_size_value ",value_size_text)
                             control_logic_function['text_size_dat'] = value_size_text; 
            });
           
            settings['text_height'] = 0
            var text_height = text_label.add(settings,"text_height",0.0,5).name("Text_height")
            text_height.onChange(function(value_height_text){
                            console.log("Text_height_value ",value_height_text) 
                            control_logic_function['text_height'] = value_height_text; 
            });
            */
            //Add component into the scene 
            //Select the component  Navigation system 
            //Get the list component 
            settings['list_nav_components'] = "" 
            settings['generate_nav_code'] = function(){
                        console.log("Generating navigation code"); 
                        //Fetch data here to running the generator to generate the navigation code  
                        fetch('/gen_nav_code', {
                                 // Declare what type of data we're sending
                                 headers: {
                                     'Content-Type': 'application/json'
                                },
                       // Specify the method
                       method: 'POST',
                       // A JSON payload
                       body: JSON.stringify({
                            "email": email_data,"payload_data":feature_add_nav   //Get the navigation 
                      })
                      }).then(function (response) { // At this point, Flask has printed our JSON
                      return response.text();
                      }).then(function (text) {
                        console.log('POST response: ');
                        alert("Generating navigation code sucessfully!")
                        var feed_back_nav_gen =  JSON.parse(text); 
                        console.log("Data_feedback from the local invironment ",feed_back_nav_gen); //Feedback 
                        //Running the code generator store inside the function 
                        //var Remove_nav_func = nav_control_com.addFolder("Remove navigation components") 
                        /*
                        var list_comp_nav = Object.keys(feature_add_nav[Object.keys(feature_add_nav)[0]][project_names])  // Add the navigation components data    
                        list_comp_nav.unshift("Non-select")
                        var device_select = Remove_nav_func.add(settings,"list_nav_components",list_comp_nav).name("Remove_list")
                        list_comp_nav.setValue("Non-select")
                        device_select.onChange(function(value_remove_com){
                                
                                console.log("Removing the navigation component part ",value_remove_com);  
                                delete feature_add_nav[Object.keys(feature_add_nav)[0]][value_remove_com]; 
                                console.log(feature_add_nav);
                                alert("Removing navigation component "+String(value_remove_com));
                                
                        });     
                        */          

              });    
            }
           //var nav_control_com = gui.addFolder("Create navigation components on hardware");
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Select the single board computer from the list 
            // /Computer_board_connected
            
            settings['board_datas'] = "";  
            fetch('/Computer_board_connected', {
                       // Declare what type of data we're sending 
                       headers: {
                            'Content-Type': 'application/json'
                       },
                      // Specify the method
                      method: 'POST',
                     // A JSON payload
                     body: JSON.stringify({
                                "email": email_data
                     })
                      }).then(function (response) { // At this point, Flask has printed our JSON 
            return response.text();
            }).then(function (text) { 
            console.log('POST response: ');
                        // Should be 'OK' if everything was successful
                         var computer_board_list = JSON.parse(text);
                         console.log("Computer board list ",computer_board_list); // Get the data of the computer board list into the select box data 
                         if(Object.keys(computer_board_list) != null){
                         var data_object_list = Object.keys(computer_board_list); //Get the list data of the board 
                         data_object_list.unshift("Non-select"); 
                         /*
                         var data_nav_obj = nav_control_com.add(settings,"board_datas",data_object_list).name("Select_board") 
                         data_nav_obj.setValue("Non-select")
                         data_nav_obj.onChange(function(value_data_board){
                                              console.log("Select boardata ",value_data_board); 
                                              navigation_code_gen["Board_data"] = value_data_board;
                                              navigation_code_gen["USB_devices"] = Object.keys(computer_board_list[value_data_board]["serial_devices"]) // Get the serail usb device list 
                                              navigation_code_gen["Camera_index"] = computer_board_list[value_data_board]["Vision_system"]["camera_array"] // Get the camera index data 
                                              console.log("USB data list ",navigation_code_gen["USB_devices"])
                                               
                         })
                         */
                        }
                        if(Object.keys(computer_board_list)[0] == "status"){
                                  console.log("No computer on board found to connect with the navigation system");
                                  notify_data('warning','No single board computer or onboard computer found connect with the system')
                        }


            });  

            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
            
            //Generate the naviation name and type of the navigation code into the robot 
            settings['input_component_name'] = ""; 
            /*
            var navigation_name_com = nav_control_com.add(settings,"input_component_name").name("Name navigation") 
             navigation_name_com.onChange(function(value_function_com){
                                  console.log("Navigation component name",value_function_com)
                                  navigation_code_gen["Name_navigation"] = value_function_com 
                                  
            })
            //Add the navigation system type select on the combobox 
            settings['Nav_type_com'] = "";
            settings['Nav_type_sys_com'] = "";
            var list_navcom_type = ['Indoor_navigation','Outdoor_navigation']
            list_navcom_type.unshift("Non-selected")
            */

            /*
            var navigation_type_com = nav_control_com.add(settings,"Nav_type_com",list_navcom_type).name("Navigation type")
            navigation_type_com.setValue("Non-selected")
            navigation_type_com.onChange(function(value_navigation_data){
                                console.log("Navgiation type selected ", value_navigation_data); //Get the navigation type data 
                                navigation_code_gen['Navigation_type'] = value_navigation_data 
                                //Get the name of the navigation add into the folder list 
                                                                
                                //Get the navigation type to choose the list 
                                var environment_list = {"Indoor_navigation":['Camera_navigation','Beacon_WiFi_navigation','Beacon_BLE_navigation'] ,"Outdoor_navigation":['point_cloud_3D','GPS','Lidar','Cellular'] }
                                //Check indoor visulise function to select the component of the navigation system 
                                var nav_sys_list = environment_list[value_navigation_data]
                                nav_sys_list.unshift("Non-selected")
                                var nav_com_system = nav_control_com.add(settings,"Nav_type_sys_com",nav_sys_list).name(navigation_code_gen["Name_navigation"]) // Get the navigaiton system select from the list of the navigaiton feature
                                nav_com_system.setValue("Non-selected")
                                nav_com_system.onChange(function(value_function_nav){
                                                        console.log("Navigation_features_component_sys ",value_function_nav);
                                                        //Append the features of the navigation type and component into the list to generate the code function features 
                                                        navigation_code_gen['Navigation_component'] = value_function_nav
                                                        alert("Now the navigation part was added into the system")
                                                        nav_com_system.remove();
                                                        //Check if found the list of udb visualize data 
                                                        var outdoor_list_device = ['GPS','Lidar',"Cellular"]   // All are connect via USB or UART to USB device
                                                        if(outdoor_list_device.includes(value_function_nav) == true){

                                                                         console.log("Hardware detected usb device");
                                                                         //Get the list of the usb device
                                                                         settings["usb_listport"] = ""; 
                                                                         console.log("USB data list ",navigation_code_gen["USB_devices"])
                                                                         var usb_list_dat = navigation_code_gen['USB_devices'] 
                                                                         usb_list_dat.unshift("Non-selected") //Add the non selected into the usb selection list for the navigation system 
                                                                         var select_usb_port = nav_control_com.add(settings,"usb_listport",usb_list_dat).name("Port_"+navigation_code_gen["Name_navigation"]) 
                                                                         select_usb_port.setValue("Non-selected") 
                                                                         select_usb_port.onChange(function(value_usb_list){

                                                                                     console.log("Selected usb data",value_usb_list);  
                                                                                     navigation_code_gen['selected_port'] = value_usb_list; //Get the selected port of the usb 
                                                                                    
                                                                                     select_usb_port.remove(); 
                                                                         });
                                                        }                                     
                                                        var camera_index_data = ["Camera_navigation","point_cloud_3D"]
                                                        if(camera_index_data.includes(value_function_nav) == true){
                                                                     console.log("Hardware detect the camera device for image sensor") 
                                                                     settings['cam_index'] = ""; 
                                                                     var camera_list_index =  navigation_code_gen["Camera_index"] 
                                                                     camera_list_index.unshift("Non-selected") 
                                                                     var select_camera_index = nav_control_com.add(settings,"cam_index",camera_list_index).name("Camera_index"); //Get the camera index data selected from the list 
                                                                     select_camera_index.setValue("Non-selected")
                                                                     select_camera_index.onChange(function(value_camera_index){ 
                                                                                   console.log("Select the camera index data",parseInt(value_camera_index),typeof(parseInt(value_camera_index)));  // select the camera index port to generate the code of the camera navigation system and report the data back to the navigation system       
                                                                                   //Add the camera into the list of the code generator function 
                                                                                   navigation_code_gen['selected_cam_index'] = parseInt(value_camera_index); //Get the camera index store in the array in integer number 
                                                                                   select_camera_index.remove();  //Remove the camera index after generatring 

                                                                     });                                                                    

                                                                 
                                                        }
                                });                                                                     
            }) 
            */
            
            //Add the feature function to generate in the dict list navigation_code_gen
            settings['Add_code_features'] = function(){
                           //Add the button feature in here 
                           console.log("Adding the features to generating the code ")
                           //Change the key input into the dynamic key instead inside the payload fo the key header data will be using the host name of the sigle board computer 
                           var  list_outdoor_devices = ['point_cloud_3D','GPS','Lidar']
                           if(list_outdoor_devices.includes(navigation_code_gen['Navigation_component']) == true){
                            //Check if the data of the component selected is in the list of camera index 
                            var check_cam_comp = ['point_cloud_3D'];  
                            if(check_cam_comp.includes(navigation_code_gen['Navigation_component']) == true){
                              payload_navigation[navigation_code_gen["Name_navigation"]] = {"Navigation_type":navigation_code_gen['Navigation_type'],"Navigation_component":navigation_code_gen['Navigation_component'],"camera_index":navigation_code_gen['selected_cam_index']}
                              project_nav_name[project_names] = payload_navigation
                              feature_add_nav[navigation_code_gen["Board_data"]] = project_nav_name; 
                              console.log("Features_added",feature_add_nav); 
                              alert("Adding the features code of navigation");
                            }
                            if(check_cam_comp.includes(navigation_code_gen['Navigation_component']) == false){
                           
                              payload_navigation[navigation_code_gen["Name_navigation"]] = {"Navigation_type":navigation_code_gen['Navigation_type'],"Navigation_component":navigation_code_gen['Navigation_component'],"Select_usb_port":navigation_code_gen['selected_port']}
                              project_nav_name[project_names] = payload_navigation 
                              feature_add_nav[navigation_code_gen["Board_data"]] = project_nav_name; 
                              console.log("Features_added",feature_add_nav); 
                              alert("Adding the features code of navigation");
                            }
                        }
                           if(list_outdoor_devices.includes(navigation_code_gen['Navigation_component']) == false){
                           var check_cam_comp =  ['Camera_navigation'] //Get the list check for the 
                           if(check_cam_comp.includes(navigation_code_gen['Navigation_component']) == true){
                              payload_navigation[navigation_code_gen["Name_navigation"]] = {"Navigation_type":navigation_code_gen['Navigation_type'],"Navigation_component":navigation_code_gen['Navigation_component'],"camera_index":navigation_code_gen['selected_cam_index']}
                              project_nav_name[project_names] = payload_navigation
                              feature_add_nav[navigation_code_gen["Board_data"]] = project_nav_name; 
                              console.log("Features_added",feature_add_nav); 
                              alert("Adding the features code of navigation");
                           }   
                           if(check_cam_comp.includes(navigation_code_gen['Navigation_component']) == false){
                           payload_navigation[navigation_code_gen["Name_navigation"]] = {"Navigation_type":navigation_code_gen['Navigation_type'],"Navigation_component":navigation_code_gen['Navigation_component']}
                           project_nav_name[project_names] = payload_navigation
                           feature_add_nav[navigation_code_gen["Board_data"]] = project_nav_name
                           console.log("Features_added",feature_add_nav); 
                           alert("Adding the features code of navigation");
                        }
                    }
                           
                          
            }
           //var Add_features_code_gen = nav_control_com.add(settings,"Add_code_features").name("Add_feature_code")
            
            //var gen_nav_code = gui.addFolder("Generate Navigation code")
            //var gen_data_code =  gen_nav_code.add(settings,"generate_nav_code").name("Generate Navigation code")
            
            //gen_nav_code.open(); 
            //nav_control_com.open(); 
            //text_label.open()
            cpath_line.open(); 
            camera_track.open();            

			let scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x333333 );
		    scene.environment = new RGBELoader().load( '../static/textures/equirectangular/venice_sunset_1k.hdr' );
		    scene.environment.mapping = THREE.EquirectangularReflectionMapping;
            let grid = new THREE.GridHelper( 20, 40, 0xffffff, 0xffffff );
			grid.material.opacity = 0.2;
		    grid.material.depthWrite = false;
		    grid.material.transparent = true;
			//scene.background = new THREE.Color(0xffffff);
		    //scene.background = new THREE.Color(0xafafaf); 
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);
                     
            

			let renderer = new THREE.WebGLRenderer({ antialias: true });
			const size = 3000;
            const divisions = 3000;
            //const gridHelper = new THREE.GridHelper( size, divisions );
            scene.add(grid);
            //label 
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);   

			var material = new THREE.LineBasicMaterial({
                                color: 0x39817d // red color
            });
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);
            // set the material for the lines of the grid helper
            //gridHelper.material = material;
            //gridHelper.position.y = -1.1;
           // adjust the position of the grid helper below the model
			
            THREE.Object3D.DefaultUp = new THREE.Vector3(1, 0, 0);

			render()
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setClearColorHex( 0xffffff, 1 );
            
			document.body.appendChild( renderer.domElement );
            const controls = new OrbitControls( camera, renderer.domElement );
		    controls.addEventListener( 'change', render); // use if there is no animation loop
			controls.minDistance = 0.01;
			controls.maxDistance = 100000;
			const loader = new PCDLoader(); // point cloud loader function for the 2D image into point clouds reconstruct and place it in differe
            //Running in the loop for real-time image use the jquery data 
			/*
             // Get the camera object from the scene
             var camera = scene.getObjectByName( 'cameraName' );
             // Set the new position of the camera
             camera.position.set( x, y, z );
             // Set the camera to look at a specific point in the scene
             camera.lookAt( new THREE.Vector3( targetX, targetY, targetZ ) );
			*/
            
            var points_list = [];  //Get the list of the point random in the function of random path and sync hardware 
            var points_list_swarm = {}; // Gt the swarm json data 
            var local_swarm_inner = []; // Get the local swarm inner 
        //Swarm control robot by select the list robot from the project
        //This functionwill be create the dome to visualize the origin of the signal like RF signal that get the from the sensor in real-time to generate the function of real-time signal avoidane or approching of robot     
        //dict_materials_data 
        
        var data_materials = { 
                 color: 0xe50101, 
                 transparent: true,
                 opacity: 0.8,
                 roughness: 0.1,
                 metalness: 0.9,
        }
        
function updateGridHelper() {
    // Remove existing grid
    if (grid) {
        scene.remove(grid);
    }

    // Find the maximum absolute coordinate among all models
    let maxCoord = 0;
    //models.forEach(model => {
     maxCoord = Math.max(maxCoord, 
            Math.abs(models.position.x), 
            Math.abs(models.position.y), 
            Math.abs(models.position.z)
    );
   

    // Calculate new grid size
    const gridSize = Math.ceil(maxCoord * gridExtensionFactor);
    const gridDivisions = 20; // You can adjust this for more or fewer grid lines

    // Create new grid
    grid = new THREE.GridHelper(gridSize * 2, gridDivisions, 0xffffff, 0x888888);
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add(grid);

    // Update renderer and camera
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    // Optionally, adjust camera position or controls target if needed
    // orbit.target.set(0, 0, 0);
    // camera.position.set(gridSize, gridSize, gridSize);
    // orbit.update();

    render();
}
//let isRunning = true;
// Modify your animate function to include grid update
function animate() {
    //if (!isRunning) return;
    requestAnimationFrame(animate);
    TWEEN.update();
    updateGridHelper(); // Add this line
    //multi_agent_task_progress();
    render();
}
/*
document.addEventListener("visibilitychange", () => {
    isRunning = !document.hidden;
    if (isRunning) animate(); // Restart when tab becomes active
});
*/

/*
function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            render();

}
window.addEventListener('resize', onWindowResize);
*/
        function dome_signal_rssi_radar(r,w,h,phi_s,phi_l,dict_materials,position_mouse){             
                 const radius = r;
                 const widthSegments = w; 
                 const heightSegments = h;
                 const phiStart = phi_s;
                 const phiLength = phi_l;
                 const geometrys = new THREE.SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength);
                 const material_dome = new THREE.MeshPhysicalMaterial(dict_materials);
                 const dome = new THREE.Mesh(geometrys, material_dome);
                 var X_pos = position_mouse['x']
                 var Y_pos = position_mouse['y']
                 dome.position.set(X_pos,1,Y_pos);
                 dome.rotation.x = 270*Math.PI/180 
                 scene.add(dome);
        }  
        function dome_position_click(){
                                  // Listen to mouse events
                                  var raycaster = new THREE.Raycaster();
                                  var mouse = new THREE.Vector2();
                                  renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
                                  function onDocumentMouseDown(event) {
                                                       // Calculate mouse position in normalized device coordinates
                                                        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                                                        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                                                        console.log("Mouse click position ",mouse.x,mouse.y); 
                                    
                                                        raycaster.setFromCamera(mouse,camera);
                                                        var position_mouse = {"x":mouse.x,"y":mouse.y} 
                                                        var intersects = raycaster.intersectObjects([gridHelper]);
                                                        console.log(intersects); 
                                                        var h = 1; 
                                                        var geometrys = new THREE.SphereGeometry(10, 32, 32, -Math.PI/2, Math.PI);
                                                        // Create a material for the dome with a transparent color and an initial opacity of 0.5
                                                        //var materials = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                                                        const materials = new THREE.MeshPhysicalMaterial(data_materials = { 
                                                             color: 0xffffff, 
                                                             transparent: true,
                                                             opacity: 0.2,
                                                             roughness: 0.1,
                                                             metalness: 0.4,
                                                        });
                                                        // Create a mesh using the geometry and material
                                                        var domes = new THREE.Mesh(geometrys, materials);
                                                        domes.position.set(-parseFloat(mouse.x*10),h,parseFloat(mouse.y*10)); 
                                                        // Add the dome to the scene
                                                        domes.rotation.z = 270*Math.PI/180
                                                        scene.add(domes);
                                                        // Adjust the opacity of the material 
                                                        materials.opacity = 0.8; 
                                }

        } 
        //Function of the wifi_localization navigation system
        function chunk(arr, size){ 
           var chunkedarray = [];   
           for (let i = 0; i < arr.length; i += size){
                  const chunk = arr.slice(i,i + size); 
                chunkedarray.push(Array.from(chunk)); 
           }
           return chunkedarray   //Return chunked data of array into the data array type of the numpy like structure 
        }
        function triangulation_calculation_coordinate(access_point_pos,access_local_trilation){   //Structure of the AP1,2,3 => var AP1 = {"AP1":[0,1]}
             //Setting the selection of the data from package data 
             
             var AP1 = new Float64Array(2); 
             var AP2 = new Float64Array(2); 
             var AP3 = new Float64Array(2);
             var access_dat = Object.keys(access_point_pos);
             var fixed_pos_1 = access_dat[0]; 
             var fixed_pos_2 = access_dat[1];
             AP1[0] = access_point_pos[fixed_pos_1][0]; 
             AP1[1] = access_point_pos[fixed_pos_1][2];  
             
             //Access point 2 
             if(settings_mobile_signal = true){
                   
                   var wifi_trilation_selected = Object.keys(access_local_trilation) 
                   var dynamic_data = wifi_trilation_selected[0] 
                   AP2[0] = access_local_trilation[dynamic_data][0]; 
                   AP2[1] = access_local_trilation[dynamic_data][2]; 
                   
             }

             //Access point 3
             AP3[0] = access_point_pos[fixed_pos_2][0]; 
             AP3[1] = access_point_pos[fixed_pos_2][1]; 
             //This input will get from the wifi post request data from the robotics access point navigation system 
             var d1 = access_point_pos[fixed_pos_1][3]; 
             var d2 = access_local_trilation[dynamic_data][3]
             var d3 = access_local_trilation[dynamic_data][3]
             console.log("Distance data return wifi ",d1,d2,d3)
             console.log("Access_Point_1 ",AP1)
             console.log("Access_Point_2 ",AP2)
             console.log("Access_Point_3 ",AP3) 
             console.log(AP2[0],AP1[0],AP2[1],AP1[1]); 
             console.log(AP3[0],AP1[0],AP3[1],AP1[1]); 
             console.log(AP2[0]-AP1[0],AP2[1]-AP1[1]); 
             console.log(AP3[0]-AP1[0],AP3[1]-AP1[1]);
             //Get the combine Array input from the whole function to input into the Float64Array() 
             var combine_array = [AP2[0]-AP1[0],AP2[1]-AP1[1],AP3[0]-AP1[0],AP3[1]-AP1[1]] 
             const multiplied_array = combine_array.map(x => 2*x);
             var A = new Float64Array(multiplied_array); // Get the array of the bombined array 
             var chunk_array = chunk(A, 2);    
             console.log(chunk_array) 
             //Now running the operation mode calculation of the b variable data 
             var b = new Float64Array(2); 
             b[0] =  d1**2 - d2**2 - AP1[0]**2 + AP2[0]**2 - AP1[1]**2 + AP2[1]**2
             b[1] =  d1**2 - d3**2 - AP1[0]**2 + AP3[0]**2 - AP1[1]**2 + AP3[1]**2 
             console.log(chunk_array,b)
             var pos_array = numeric.solve(chunk_array,b)
             console.log("Coordinate movement ",pos_array)
             new_coordinates_1 = pos_array; //Get the update coordinate data 
             //Update the new value of the coordination  
             AP2[0] = new_coordinates_1[0]
             AP2[1] = new_coordinates_1[1]
             console.log("AP2 update",AP2);
             //update_ap_coordinates(2,new_coordinates_1)              
             console.log(AP1,AP2,AP3);
             console.log("Data location of the updated data ",AP2[0],AP2[1]);             
             //d2 = calculate_distance(70,64,-30)  
             //Get an update data in trilation calculation input from the new loop 
             var combine_array2 = [AP2[0]-AP1[0],AP2[1]-AP1[1],AP3[0]-AP1[0],AP3[1]-AP1[1]] 
             console.log(combine_array2);
             const multiplied_array2 = combine_array2.map(x => 2*x);
             A = new Float64Array(multiplied_array2)
             var chunk_array_2 = chunk(A, 2); 
             console.log(chunk_array_2)
             b = new Float64Array(2)
             b[0] = d1**2 - d2**2 - AP1[0]**2 + AP2[0]**2 - AP1[1]**2 + AP2[1]**2 
             b[1] = d1**2 - d3**2 - AP1[0]**2 + AP3[0]**2 - AP1[1]**2 + AP3[1]**2 
             var pos_array_update = numeric.solve(chunk_array_2,b); // Get the position of the array data 
             console.log(pos_array_update); 
             var x_update = pos_array_update[0] 
             var y_update = pos_array_update[1]
             console.log("Coordinate_update data ",x_update,y_update)    
             return [x_update,y_update]; //return the data of the x,y update data of the coordination navigation 
             
         }
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                             //Navigation function of the  system
              
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
       
        function infiniteLoop(){
                
               /*          
		       loader.load( '../static/models/pcd/ascii/leaf7_image.pcd', function ( points ) {
                       points.geometry.center();
                       points.geometry.rotateX( Math.PI );
                       
                       points.name = 'leaf7_image.pcd';
					   settings['size']  = points.material; 
                       settings['color'] = points.material; 
               */        
               // Create a new CSS2DObject with the overlay element

                if(settings['real_rand_path'] == true){   
                    
                       let min = 1; 
                       let max = 10;
                       var randomIntX = Math.floor(Math.random() * (max - min + 1)) + min;
                       var randomIntY = Math.floor(Math.random() * (max - min + 1)) + min;
                       var randomIntZ = Math.floor(Math.random() * (max - min + 1)) + min; 
                       console.log(randomIntX,randomIntY,randomIntZ); 
                       var material = new THREE.LineBasicMaterial({ color: control_logic_function['color_line'] }); // Red color
                       //Calculate the position from the IMU data to draw the line and move the point cloud into the difference position 
                       //Get the origin position from the polar_co-ordination 
                       if (points_list.length > 3){         
                               var p_point = 0; 
                               for(p_point > 0; p_point <= points_list.length-1; p_point++){                    
                                   //points_list.shift(); 
                                   //points_list.unshift(points_list.pop());
                                   points_list.splice(p_point,1);

                               }
                               points_list.splice(0, points_list.length);   //Clear 
                            }
                       points_list.push(new THREE.Vector3(randomIntX,randomIntY,randomIntZ)); 
                              
                       console.log("Move_path",points_list);
                       
                       try{
                       var curve = new THREE.CatmullRomCurve3(points_list);
                       // Define the geometry of the line using the curve
                       var geometry = new THREE.Geometry();
                       geometry.vertices = curve.getPoints(50); // Get 50 points along the curve
                           // Create the line object
                       
                       var line = new THREE.Line(geometry, material);
                       scene.add(line);
                       }
                       catch{
                             console.log("Path process error")
                       }
                       var floader = new THREE.FontLoader();
                       floader.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                           // Create the text geometry using the loaded font
                           //In this case text label will be using the name of the robot using in the project that upload into the website
                        
                           var textGeometry = new THREE.TextGeometry(String(current_robot["current_robot"])+' ==>('+String(randomIntX)+","+String(randomIntY)+","+String(randomIntZ)+")", {
                            font: font,
                            size: parseFloat(control_logic_function['text_size_dat']),
                            height: control_logic_function['text_height']
                           });

                          // Create a mesh from the text geometry
                          //var material = new THREE.MeshBasicMaterial({color:control_logic_function['text_color']});
                          //var textMesh = new THREE.Mesh(textGeometry, material);
                          // Add the text mesh to the scene
                         // textMesh.position.set(randomIntX,randomIntY,randomIntZ)
                          //scene.add(textMesh);
                          label_controldata(randomIntX,randomIntY,randomIntZ);

                          /*
                          const geometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
                          const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                          var cube = new THREE.Mesh(geometry, material);
                          cube.position.set(randomIntX,randomIntY,randomIntZ);
                          scene.add(cube);
                             //label css test and update realtime 
                           var labelDiv = document.createElement('div');
                           var namecut_length = String(current_robot["current_robot"])+' ==>'+"("+String(parseInt(randomIntX))+","+String(parseInt(randomIntY))+","+String(parseInt(randomIntZ))+")"
                           var construct_namecut = namecut_length  //filename.split(namecut_length)[0];
                           labelDiv.className = 'label';
                           labelDiv.textContent = construct_namecut;
                           var label = new CSS2DObject(labelDiv);
                           // Function to update label position
                           function updateLabelPosition() {
                             const box = new THREE.Box3().setFromObject(cube);
                             const center = new THREE.Vector3();
                             box.getCenter(center);
                            // Calculate the offset from the model's position to its center
                            const offset = center.sub(cube.position);
                            // Set the label position to the center of the model
                            label.position.copy(offset);

                             }
                            updateLabelPosition();
                            cube.add(label); 
                           */

                          });
                          
                        const xAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                            new THREE.LineBasicMaterial({ color: 0xff0000 })
                        );
                        const yAxis = new THREE.Line(
                            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                            new THREE.LineBasicMaterial({ color: 0x00ff00 })
                        );
                        const zAxis = new THREE.Line(
                            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                            new THREE.LineBasicMaterial({ color: 0x0000ff })
                        );
                        if(control_logic_function['Axes_path'] == true){
                        // Create an object to group the axes and add them to the scene
                        const axesGroup = new THREE.Group();
                        axesGroup.add(xAxis, yAxis, zAxis);
                        axesGroup.position.set(randomIntX,randomIntY,randomIntZ)
                        models['position'] = {'x':randomIntZ,'y':randomIntY,'z':randomIntZ}
                        var cam_r_polar = Math.sqrt(Math.pow(randomIntX,2)+Math.pow(randomIntY,2)); 
                        var cam_polar_angle_x  = Math.acos(randomIntX/cam_r_polar)
                        var cam_polar_angle_y  = Math.asin(randomIntY/cam_r_polar)
                        if(control_logic_function['fps_cam_logic'] == true){
                                
                                camera.position.set(randomIntX,randomIntY,randomIntZ );
                              
                          }
                          if(control_logic_function['orbit_cam_logic'] == true){
                                 //Control the angle (x,y,z)
                                 if(control_logic_function['follow_cam'] == true){
                                              camera.rotation.x = cam_polar_angle_x //  row 
                                              camera.rotation.y = cam_polar_angle_y  //  yaw
                                              camera.rotation.z = 90*Math.PI/180  //  pitch
                                 }
                        }
                    
                        scene.add(axesGroup);    
                        }
                        //Add the signal generator position in the case generated in the function 
                        if(main_pos_signal !={}){

                            //Running the for loop 
                            
                            for(var wi in main_pos_signal){
                                        console.log("Navigation components ",wi); //Get the data pos from each components 
                                        var data_p= Object.keys(main_pos_signal) // Get the list of the navigation components 
                            
                            var len_wifi_comps = data_p.length; // Get the list of the wifi signal 
                            
                            console.log("Check_pos_data ",main_pos_signal[wi]);                                
                            console.log(wi)
                            var nav_name =  wi //Object.keys(main_pos_signal)[0] // Input the number of the nav name component to running inside the loop to generate connection code 
                            console.log("Name devices ", nav_name);
                            var nav_type = main_pos_signal[nav_name]
                            console.log(nav_type); 
                            var data_nav = Object.keys(nav_type)[0];
                            console.log(data_nav); 
                            var data_nav_con = nav_type[data_nav]
                            var data_com = Object.keys(data_nav_con)[0];
                            console.log(data_com);
                            var data_pos = main_pos_signal[nav_name][data_nav][data_com]
                            //}
                            //console.log("Data position ",data_pos); 
                            //var list_indoor = ['Camera_navigation','Beacon_WiFi_navigation','Beacon_BLE_navigation'] 
                            //var list_outdoor = ['point_cloud_3D','GPS','Lidar']   
                            //if(list_indoor.includes(nav_comp) == true){
                            console.log("Generate the function from the json main position path ")
                            
                                                      
                                                        var h = data_pos['z']; 
                                                        //Fetch the data of the signal strange convert from the RSSI fetching hardware 
                                                        var r = 0; 
                                                        
                                                        fetch('/rssi_beacon_hw', {
                                                              // Declare what type of data we're sending
                                                              headers: {
                                                                   'Content-Type': 'application/json'
                                                              },
                                                             // Specify the method
                                                             method: 'POST',
                                                             // A JSON payload
                                                             body: JSON.stringify({
                                                                     "email": email_data,"wifi_device":nav_name     //Sending the marker wifi name to the back-end to get the feedback position from the robot hardware 
                                                            })
                                                            }).then(function (response) { // At this point, Flask has printed our JSON
                                                            return response.text();
                                                          }).then(function (text) {

                                                          console.log('POST response: ');
                                                         // Should be 'OK' if everything was successful
                                                                var radius_signal =  JSON.parse(text);
                                                                console.log(radius_signal);
                                                                //get the wifi name from the nav_name to get the radius data from signal on each robot 
                                                                //Object.keys(radius_signal)[0]
                                                                try{
                                                                    var real_radius = radius_signal[nav_name]['distance'] 
                                                                    console.log(real_radius);
                                                                    data_wifi_localization['radious'] = real_radius
                                                                }
                                                                catch{
                                                                        alert("Device middleware was not generated into the hardware or middleware is offline please check")
                                                                }                                
                                                       });
                                                        
                                                        r = data_wifi_localization['radious']
                                                        data_wifi_localization['text_pos'] = {'x':data_pos['x'],'y':data_pos['y'],'z':data_pos['z']}                               
                                                        //Add the dynamic loop of the RSSI signal  
                                                        var geometrys = new THREE.SphereGeometry(r, 32, 32, -Math.PI/2, Math.PI);
                                                        var materials = new THREE.MeshBasicMaterial({color: settings['dome_color']});
                                                        var wireframe = new THREE.WireframeGeometry(geometrys)
                                                        var domes_wifi = new THREE.LineSegments(wireframe,materials);                               
                                                        //Create a mesh using the geometry and material
                                                        //var domes_wifi = new THREE.Mesh(geometrys, materials);
                                                        //Text label and the position data text mesh 
                                                        
                                                        //Add the axis of the signal position 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(data_pos['x'],r+data_pos['y'],data_pos['z']);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        }
                                                     
                                                        domes_wifi.position.set(data_pos['x'],data_pos['y'],h); // Add the  x,z,y 
                                                        // Add the dome to the scene
                                                        domes_wifi.rotation.z = 270*Math.PI/180
                                                        scene.add(domes_wifi);
                                                        // Adjust the opacity of the material 
                                                        materials.opacity = 0.2;
                                                        var floader_dat = new THREE.FontLoader();
                                                        floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                                                        // Create the text geometry using the loaded font
                                                        //In this case text label will be using the name of the robot using in the project that upload into the website
                                                        var textGeometry_dome = new THREE.TextGeometry(String(nav_name)+' ==>('+String(data_wifi_localization['text_pos']['x'])+","+String(data_wifi_localization['text_pos']['y'])+","+String(data_wifi_localization['text_pos']['z'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                                        // Create a mesh from the text geometry
                                                        var materials_label = new THREE.MeshBasicMaterial({color:settings['color_label']}); //Get the color from the label 
                                                        var textMesh_dome = new THREE.Mesh(textGeometry_dome, materials_label);
                                                        // Add the text mesh to the scene
                                                        //This part of the code will add into the animation function of the threejs  here is the test to add the data of the current selected mobile wifi localization to calculate the position of the wifi in real-time
                                                        
                                                    
                                                        if(len_wifi_comps >=3){
                                                                      console.log("Enable the wifi localization dynamic trilationcalculation algorithm "); //Enable the data append into th list of the list of the wifi mobile selection function and static setting of wifi 
                                                                      //if len >3 then add the wifi localization data into the access point data 
                                                                      console.log("Trigger the position control of the navigation system ")
                                                                      //Running the new position updated on the trilation calculation 
                                                                      //Add list of the distance of the data             
                                                                      var access_p =0; 
                                                                      for(access_p >=0;access_p <=len_wifi_comps-1;access_p++){
                                                                                           console.log("Checking the component access point data in the loop "); 
                                                                                           var type_navsep =  Object.keys(main_pos_signal[wi])
                                                                                           var navigation_com = Object.keys(main_pos_signal[wi][type_navsep]) 
                                                                                           var access_fixed_point=  main_pos_signal[wi][type_navsep][navigation_com]
                                                                                           console.log(access_point_pos) 
                                                                                           var x_ap = access_fixed_point['x']; 
                                                                                           var y_ap = access_fixed_point['y']; 
                                                                                           var z_ap = access_fixed_point['z'];
                                                                                           if(settings_mobile_signal[wi] != true){

                                                                                                    access_point_pos[wi] = [x_ap,y_ap,z_ap,r]; // Append the access point of each one update into the system  
                                                                                                    
                                                                                           }
                                                                                           if(settings_mobile_signal[wi] == true){
                                                                                                   access_local_trilation[wi] = [x_ap,y_ap,z_ap,r];

                                                                                           }
                                                                                        

                                                                     }                            
                                                                     console.log("Access_point key data ",access_point_pos); //Get the local access point 
                                                                     console.log("Dynamic accesspoint data ",access_local_trilation);  //Get the wifi access point 
                                                                     
                                                                     var updated_coordinate = triangulation_calculation_coordinate(access_point_pos,access_local_trilation); // Get the main post signal data of   
                                                                     console.log("Trilation calculation update data ", updated_coordinate); 
                                                                     // update the position here in the code for the RSSI signal data 
                                                                     // if the location of the data update is only 3D fixed the position then using default Y-axis from the setting 
                                                                     //The object to update is dome of wifi signal localization boundary 
                                                                     if(settngs_mobile_signal[wi] == true){
                                                                             domes_wifi.position.set(updated_coordinate[0],access_local_trilation[wi][1],updated_coordinate[1]); // Add the  x,z,y 
                                                                             axesGroupS.position.set(updated_coordinate[0],r+access_local_trilation[wi][1],updated_coordinate[1]);
                                                                             textMesh_dome.position.set(updated_coordinate[0],r+access_local_trilation[wi][1]+1,updated_coordinate[1]);
                                                                     }
                                                                     if(settings_mobile_signal[wi] != true){
                                                                             domes_wifi.position.set(updated_coordinate[0],access_point_pos[wi][1],updated_coordinate[1]); // Add the  x,z,y 
                                                                             axesGroupS.position.set(updated_coordinate[0],r+access_point_pos[wi][1],updated_coordinate[1])
                                                                             textMesh_dome.position.set(updated_coordinate[0],r+access_point_pos[wi][1]+1,updated_coordinate[1]);
                                                                     }
                                                                      

                                                        }
                                                        
                                                        if(len_wifi_comps <3 || len_wifi_comps >=3){
                                                                    console.log("Deactivate the mobile dynamic trilation calculation");
                                                                                                                       
                                                                    textMesh_dome.position.set(data_wifi_localization['text_pos']['x'],r+data_wifi_localization['text_pos']['y']+1,data_wifi_localization['text_pos']['z'])
                                                        }
                                                        scene.add(textMesh_dome);
                                                        
                           });                                                        
                        }
                                  
                        updateGridHelper();
                  }
                  if (lidar_navigationmap !={}){
                                  console.log("Lidar navigation function for the point cloud map of lidar mapping"); 
                             
                                  for(var lidar_dat in lidar_navigationmap){
                                                   console.log("Lidar navigation data ",lidar_dat,lidar_navigationmap[lidar_dat]); 
                                                   var lidar_dat_main = lidar_navigationmap[lidar_dat]; // Get the lidar main data 
                                                   var lidar_dat_type = Object.keys(lidar_navigationmap[lidar_dat])[0] //Get the lidar data type 
                                                   var lidar_dat_com = Object.keys(lidar_navigationmap[lidar_dat][lidar_dat_type])[0] 
                                                   var lidar_characteristic = lidar_navigationmap[lidar_dat][lidar_dat_type][lidar_dat_com]  
                                                   console.log("Get the lidar charateristic ",lidar_characteristic); 
                                                   
                                                   //Append the position of the 3D model of the lidar data and label text of the lidar position 
                                                       
                                                 if(lidar_characteristic['lidar_state'] == true) 
                                                           {
                                                                console.log("Data lidar generator ")  
                                                               //Get the position of the axes here 
                                                               //Get the posion  
                                                               //request the lidar back-end to process the point cloud data of the lidar mapping visualization on the roboreactor navigaiton system 
                                                               fetch('/lidar_res_request', {

                                                                 // Declare what type of data we're sending   
                                                                 headers: {
                                                                     'Content-Type': 'application/json'
                                                                 },
                                                                // Specify the method
                                                                method: 'POST',
                                                                // A JSON payload  
                                                                body: JSON.stringify({
                                                               "email":email_data  // Get the lidar name from the list of the loop to collect the streaming lidar data  
                                                               })
                                                               }).then(function (response) { // At this point, Flask has printed our JSON
                                                                return response.text();
                                                               }).then(function (text) {
                                                                    console.log('POST response: ');
                                                                    var lidar_data_stream = JSON.parse(text); //Data stream of the lidar from the back-end request
                                                                    console.log("Get the lidar data",lidar_data_stream[email_data]); // Get the data from the data streamer function 
                                                                    var lidar_embed = lidar_data_stream[email_data]; 
                                                                    //Load the axes of the lidar position 
                                                                    //console.log("Get the real-time postion of the lidar axes function",lidar_data_stream[lidar_dat]) // This will request from the hardware sync function of the odometry position 
                                                                    
                                                                    //Get the raw data of the lidar data from the function of the code
                                                                    //Get lidar plot data using range and angle of the plot funcition 
                                                                    var lidar_index = 0; 
                                                                    console.log("Lidar data internal ",lidar_embed); // Get the lidar embed  
                                                                    var list_lidar = Object.keys(lidar_embed); 
                                                                    console.log("Get the list lidar components",list_lidar);                                                                      
                                                                    console.log("list_lidar_components ",list_lidar); // Get the list lidar components function 
                                                                    for(lidar_index >0;lidar_index <= list_lidar.length-1;lidar_index++){
                                                                                      var lidar_names = list_lidar[lidar_index]
                                                                                      var lidar_streaming = lidar_embed[list_lidar[lidar_index]]; 
                                                                                      
                                                                                      var ranges_lidar = lidar_streaming['Ranges'] 
                                                                                      var angles_lidar = lidar_streaming['Angles'] 
                                                                                      console.log("Lidar parameters ",ranges_lidar,angles_lidar);  
                                                                                      var index_range = 0; 
                                                                                      for(index_range > 0;index_range < ranges_lidar.length-1 ;index_range++){
                                                                                                 var radians = angles_lidar[index_range] *(Math.PI / 180);

                                                                                                 var x_polar = (ranges_lidar[index_range]/100)*Math.cos(radians); // Get the index range plot data for the x axis 
                                                                                                 var y_polar = (ranges_lidar[index_range]/100)*Math.sin(radians); // Get the index range plot data for the y axis                                         
                                                                                                 var z_polar = 1 
                                                                                                 console.log("Coordinate_polar",x_polar,y_polar);   
                                                                                                 //Get the 3D data to visualize the data of the lidar dynamic mapping value 
                                                                                                 
                                                                                                 //lidar_array_pcd.push({x_polar,y_polar,z_polar}); // Get the the data of the polar coordination 
                                                                                                 //console.log("Point cloud data array",lidar_array_pcd); // Get the polar coordination data of the pcd point cloud data 
                                                                                                 var pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                                                                                                 // Create a material for the point 
                                                                                                 var pointMaterial = new THREE.MeshBasicMaterial({ color: lidar_characteristic['lidar_pcd_color']}); // Set the color from the default setting in dynamic GUI 
                                                                                                 // Create a point mesh
                                                                                                 var point = new THREE.Mesh(pointGeometry, pointMaterial);
                                                                                                 //Get the lidar characteristic to running the default position of the lidar to be able to 
                                                                                                 var x_dat_polar = lidar_characteristic['x']; // Get the x_polar characteristic data 
                                                                                                 var y_dat_polar = lidar_characteristic['y']; // Get the y_polar characteristic data 
                                                                                                 var z_dat_polar = lidar_characteristic['z']; // Get the z_polar characteristic data 
                                                                                                 console.log("Default setting parameters data ", x_dat_polar,y_dat_polar,z_dat_polar); //Display the local data parameters 
                                                                                                 //Dynamic motion input sync from the hardware of odometry sensor will move the navigation component around with 3d models and move alongside with the navigation system 
                                                                                                 //Add Axis of the lidar position into the scene of the navigation system 
                                                                                                 var axesGroupSl = new THREE.Group();
                                                                                                 var xAxisSl = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                                                                      new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                                                                 );
                                                                                                 var  yAxisSl= new THREE.Line(
                                                                                                  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                                                                  new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                                                                 );
                                                                                                 var zAxisSl = new THREE.Line(
                                                                                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                                                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                                                                 );
                                                                                                 if(control_logic_function['Axes_path'] == true){
                                                                                                                    // Create an object to group the axes and add them to the scene
                                                                                                                    axesGroupSl.add(xAxisSl, yAxisSl, zAxisSl);
                                                                                                                    axesGroupSl.position.set(lidar_characteristic['x'],lidar_characteristic['y']+0.5,lidar_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                                                                                    scene.add(axesGroupSl);    
                                                                                                 }

                                                                                                 //Add the text label here in dynamic mode css2d
                                                                                                 //lidar_position_label["lidar_label"] = {'x':x_dat_polar,'y':y_dat_polar,'z':z_dat_polar}; 
                                                                                                 point.position.set(x_polar+x_dat_polar, y_dat_polar,y_polar+z_dat_polar); // Set the position of the point  // This position set will be added in the animation for the animation mode selection mode 
                                                                                                 scene.add(point);
                                                                                                
                                                                                            
                                                                                                                             
                                                                                       } 
                                                                }                                                                   
                                                                 
                                                                });   
                                                                       
                                                               //Load the 3D model of the label mesh data 
                                                               
                                                           }                                                           
                                                           if(lidar_characteristic['lidar_state'] == false){
                                                              //Lodar the axes of the lidar position 
                                                              //Lodar the 3D model of the label mesh data 

                                                           }

                                                             

                                                
                                                                   
                                 }
                             

                  }
                  if(camera_navigationmap != {}){
                                   console.log("Camera_navigation system ")
                                   for(var cam_wi in camera_navigationmap){

                                            console.log("Camera navigation data ",cam_wi,camera_navigationmap[cam_wi])            
                                            //Add the camera 3d model function into the scene 
                                            var data_cam_main = camera_navigationmap[cam_wi] 
                                            var data_cam_type = Object.keys(data_cam_main)[0]
                                            var data_cam_com = Object.keys(camera_navigationmap[cam_wi][data_cam_type])[0]
                                            var cam_characteristic = camera_navigationmap[cam_wi][data_cam_type][data_cam_com] 
                                            console.log(cam_characteristic); 
                                            var floader_dat = new THREE.FontLoader();
                                            floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                                            // Create the text geometry using the loaded font
                                            //In this case text label will be using the name of the robot using in the project that upload into the website
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             //Add the camera model into the certain position in the scene 
                                                          // Instantiate a loader
                                            /*
                                            const loader = new GLTFLoader();
                                            // Load a glTF resource
                                            loader.load('../static/asset_scene_part/camera_tracking.glb',function ( gltf ) {
                                                        gltf.scene.position.set(cam_characteristic['x'],cam_characteristic['y'],cam_characteristic['z'])
                                                  		scene.add(gltf.scene);
                                         	});
                                            */
                                            var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(cam_characteristic['x'],cam_characteristic['y']+0.5,cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            //Add as label css2d instead 
                                            /*
                                            var textGeometry_dome = new THREE.TextGeometry(String(cam_wi)+' ==>('+String(cam_characteristic['x'])+","+String(cam_characteristic['y'])+","+String(cam_characteristic['z'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_dome = new THREE.Mesh(textGeometry_dome, materials_label);
                                            // Add the text mesh to the scene
                                            textMesh_dome.position.set(cam_characteristic['x'],cam_characteristic['y']+1,cam_characteristic['z'])
                                            scene.add(textMesh_dome);
                                            */

                                            label_controldata(cam_characteristic['x'],cam_characteristic['y'],cam_characteristic['z']); //Get the position from the camera position 

                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            //Get the data fetching real-time data of the QR code camera 
                                            fetch('/camera_nav_stream', {

                                                  // Declare what type of data we're sending  
                                                  headers: {
                                                       'Content-Type': 'application/json'
                                                },

                                              // Specify the method
                                             method: 'POST',

                                            // A JSON payload 
                                           body: JSON.stringify({
                                                     "email":email_data 
                                           })
                                          }).then(function (response) { // At this point, Flask has printed our JSON
                                               return response.text();
                                         }).then(function (text) {

                                               console.log('POST response: ');
                                               // Should be 'OK' if everything was successful
                                               var real_cam_position = JSON.parse(text);
                                               console.log("Get the real_time_cam",real_cam_position);
                                               var posi_cam_real = real_cam_position[project_names]; //Get the position of the 
                                               console.log("Get camera_QR code tracking position",posi_cam_real);
                                               //Select the camera index data from the generated code 
                                               // /gen_local_request 
                                               fetch('/gen_local_request', {
                                                  // Declare what type of data we're sending
                                                  headers: {
                                                    'Content-Type': 'application/json'
                                               },
                                              // Specify the method
                                              method: 'POST',
                                              // A JSON payload
                                              body: JSON.stringify({
                                                        "email": email_data 
                                              })
                                              }).then(function (response) { // At this point, Flask has printed our JSON
                                              return response.text();
                                             }).then(function (text) {
                                                            console.log('POST response: ');
                                                           // Should be 'OK' if everything was successful
                                                           var cam_data_json = JSON.parse(text); //Get the data of the navigation component to get the camera index 
                                                           console.log("Get the component json",cam_data_json); //Get the local json gen_nav 
                                                           var host_name = Object.keys(cam_data_json["navigation_payload"]) 
                                                           var project_name = Object.keys(cam_data_json["navigation_payload"][host_name]) //Get the project name of the  navigation system 
                                                           var camera_info_dat = cam_data_json["navigation_payload"][host_name][project_name][cam_wi]  //Get the camera data payload from the camera name input function 
                                                           console.log("Get the camera information ",camera_info_dat['camera_index']); //Get the camera data payload information to extract the camera index data 
                                                           console.log("Get the cameera position ",posi_cam_real[camera_info_dat['camera_index']]); //Get the camera index data                                                              
                                                           var position_cam_qr = posi_cam_real[camera_info_dat['camera_index']]; 
                                                //Top View position
                                                console.log("Camera_position_random_mode",cam_characteristic['view_pos']); 
                                                if(cam_characteristic['view_pos'] == "Top"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],1,-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            /*
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],1,-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'])
                                            scene.add(textMesh_cam);
                                              */
                                              label_controldata(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],1,-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z']);

                                             }
                                             if(cam_characteristic['view_pos'] == "Side"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z'],1);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            /*
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'],1)
                                            scene.add(textMesh_cam);
                                            */
                                            label_controldata(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],1,-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z']);

                                             
                                        }   
                                                             
                                         });
                                            
                                             
                                         });
                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                        });
                                       
                                            //Tract the current position that camera detect 
                                
                            }

                  }
                
                }

                      if(settings['sensor_sync'] == true){
                                    
                                  console.log("Enable the computational sensor sync angle", settings['sensor_sync'])
                                  try{
                                        //Feth the imu or local sensor data back into the website 
                                       fetch('/imu_for_map', {
                                             // Declare what type of data we're sending
                                             headers: {
                                                'Content-Type': 'application/json'
                                             },
                                             // Specify the method
                                             method: 'POST',
                                             // A JSON payload
                                            body: JSON.stringify({
                                                    "email": email_data   // input the personal account data to request the back-end data
                                            })
                                            }).then(function (response) { // At this point, Flask has printed our JSON
                                            return response.text();
                                           }).then(function (text) {
                                             console.log('POST response: ');
                                             // Should be 'OK' if everything was successful
                                            //console.log(text); 
                                            var position_imu_data = JSON.parse(text); // imu_sensor data 
                                            console.log(position_imu_data); //Get the imu data contain in the sensor
                                             //This will be input the data from the other dometry sensor and navigation system 
                                            var randomIntX  = position_imu_data['dx']+1; 
                                            var randomIntY  = position_imu_data['dy']; 
                                            var randomIntZ = position_imu_data['dz']; 
                                            console.log(randomIntX,randomIntY,randomIntZ)
                                            
                                            grid.position.y = randomIntY; 
                                            var material = new THREE.LineBasicMaterial({ color: control_logic_function['color_line'] }); // Red color
                                            //Calculate the position from the IMU data to draw the line and move the point cloud into the difference position 
                                            //Get the origin position from the polar_co-ordination 
                                            if (points_list.length > 3){         
                                                      var p_point = 0; 
                                                      for(p_point > 0; p_point <= points_list.length-1; p_point++){                    
                                                         //points_list.shift(); 
                                                        //points_list.unshift(points_list.pop());
                                                        points_list.splice(p_point,1);

                                           }
                                        }
                                       points_list.push(new THREE.Vector3(randomIntX,randomIntY,randomIntZ)); 
                                       console.log("Move_path",points_list);
                                       try{
                                          var curve = new THREE.CatmullRomCurve3(points_list);
                                           // Define the geometry of the line using the curve
                                          var geometry = new THREE.Geometry();
                                          geometry.vertices = curve.getPoints(50); // Get 50 points along the curve
                                          // Create the line object
                                          var line = new THREE.Line(geometry, material);
                                          scene.add(line);
                                      }
                                      catch{
                                               console.log("Path process error")
                                     }

                      
                       //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                           //label css test and update realtime 
                           label_controldata(randomIntX,randomIntY,randomIntZ); 

                       //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                       if(control_logic_function['swarm_mode'] != true){ 
                          // Create a mesh from the text geometry
                          console.log("Swarm enable function")
                         
                          
                          try{
                            //Feth the imu or local sensor data back into the website 
                            fetch('/imu_for_map', {
                           // Declare what type of data we're sending
                           headers: {
                           'Content-Type': 'application/json'
                           },
                          // Specify the method
                          method: 'POST',
                          // A JSON payload
                         body: JSON.stringify({
                            "email": email_data   // input the personal account data to request the back-end data
                         })
                         }).then(function (response) { // At this point, Flask has printed our JSON
                         return response.text();
                         }).then(function (text) {

                              console.log('POST response: ');
                              // Should be 'OK' if everything was successful
                              //console.log(text); 
                              var position_imu_data = JSON.parse(text); // imu_sensor data 
                              console.log(position_imu_data); //Get the imu data contain in the sensor  
                                                         
                             // textMesh.rotation.x = position_imu_data['AngleDegX']*Math.PI/180
                             // textMesh.rotation.y = position_imu_data['AngleDegZ']*Math.PI/180
                             // textMesh.rotation.z = position_imu_data['AngleDegY']*Math.PI/180
                            
                             
                         });
                        }
                        catch{
                            console.log("Error no hardware syncronize on the web");
                        }

                      }
                 
                        const xAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                            new THREE.LineBasicMaterial({ color: 0xff0000 })
                        );
                        const yAxis = new THREE.Line(
                            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                            new THREE.LineBasicMaterial({ color: 0x00ff00 })
                        );
                        const zAxis = new THREE.Line(
                            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                            new THREE.LineBasicMaterial({ color: 0x0000ff })
                        );
                        if(control_logic_function['Axes_path'] == true){
                        // Create an object to group the axes and add them to the scene
                        const axesGroup = new THREE.Group();
                        axesGroup.add(xAxis, yAxis, zAxis);
                        axesGroup.position.set(randomIntX,randomIntY,randomIntZ)
                        try{
                            //Feth the imu or local sensor data back into the website 
                            fetch('/imu_for_map', {
                           // Declare what type of data we're sending
                           headers: {
                           'Content-Type': 'application/json'
                           },
                          // Specify the method
                          method: 'POST',
                          // A JSON payload
                         body: JSON.stringify({
                            "email": email_data   // input the personal account data to request the back-end data
                         })
                         }).then(function (response) { // At this point, Flask has printed our JSON
                         return response.text();
                         }).then(function (text) {

                              console.log('POST response: ');
                              // Should be 'OK' if everything was successful
                              //console.log(text); 
                              var position_imu_data = JSON.parse(text); // imu_sensor data 
                              console.log(position_imu_data); //Get the imu data contain in the sensor  
                              axesGroup.rotation.x = -position_imu_data['AngleDegX']*Math.PI/180
                              axesGroup.rotation.y = position_imu_data['AngleDegZ']*Math.PI/180
                              axesGroup.rotation.z = position_imu_data['AngleDegY']*Math.PI/180
                              var x_polar = Math.cos(position_imu_data['AngleDegX'])
                              var y_polar = Math.sin(position_imu_data['AngleDegZ']) 
                              var r_polar = Math.sqrt(Math.pow(x_polar,2)+Math.pow(y_polar,2)); 
                              var x_polar_ = r_polar*Math.sin(position_imu_data['AngleDegX'])*Math.cos(position_imu_data['AngleDegY'])
                              var y_polar_ = r_polar*Math.sin(position_imu_data['AngleDegX'])*Math.sin(position_imu_data['AngleDegY'])
                              var z_polar_ = r_polar*Math.cos(position_imu_data['AngleDegX'])
                              var cam_r_polar = Math.sqrt(Math.pow(randomIntX,2)+Math.pow(randomIntY,2)); 
                              var cam_polar_angle_x  = Math.acos(x_polar/r_polar)
                              var cam_polar_angle_y  = Math.asin(y_polar/r_polar)
                              
                              if(control_logic_function['fps_cam_logic'] == true){
                                
                                   camera.position.set(randomIntX,randomIntY,randomIntZ );
                                     
                              }
                              if(control_logic_function['orbit_cam_logic'] == true){
                                 //Control the angle (x,y,z)
                                 if(control_logic_function['follow_cam'] == false){
                                              camera.rotation.x = -position_imu_data['AngleDegX']*Math.PI/180 //  row 
                                              camera.rotation.y = position_imu_data['AngleDegZ']*Math.PI/180  //  yaw
                                              camera.rotation.z = position_imu_data['AngleDegY']*Math.PI/180  //  pitch
                                 }
                                 if(control_logic_function['follow_cam'] == true){
                                              camera.rotation.x = cam_polar_angle_x //  row 
                                              camera.rotation.y = cam_polar_angle_y  //  yaw
                                              camera.rotation.z = position_imu_data['AngleDegY']*Math.PI/180  //  pitch
                                 }

                          }


                         });
                         if(main_pos_signal !={}){
                           //Running the for loop 
                          for(var wi in main_pos_signal){
                                   console.log("Navigation components ",wi); //Get the data pos from each components 
                                   var data_p= Object.keys(main_pos_signal) // Get the list of the navigation components  
                                   console.log("Check_pos_data ",main_pos_signal[wi]);   

                                   console.log(wi)
                                   var nav_name =  wi //Object.keys(main_pos_signal)[0] // Input the number of the nav name component to running inside the loop to generate connection code 
                                   console.log("Name devices ", nav_name);
                                   var nav_type = main_pos_signal[nav_name]
                                   console.log(nav_type); 
                                   var data_nav = Object.keys(nav_type)[0];
                                   console.log(data_nav); 
                                   var data_nav_con = nav_type[data_nav]
                                   var data_com = Object.keys(data_nav_con)[0];
                                   console.log(data_com);
                                   var data_pos = main_pos_signal[nav_name][data_nav][data_com]
   
                                   console.log("Generate the function from the json main position path ")

                          
                            var h = data_pos['z']; 
                            //Fetch the data of the signal strange convert from the RSSI fetching hardware 
                            var r = 0; 
                            
                            fetch('/rssi_beacon_hw', {
                                  // Declare what type of data we're sending
                                  headers: {
                                       'Content-Type': 'application/json'
                                  },
                                 // Specify the method
                                 method: 'POST',
                                 // A JSON payload
                                 body: JSON.stringify({
                                         "email": email_data,"wifi_device":nav_name     //Sending the marker wifi name to the back-end to get the feedback position from the robot hardware 
                                })
                                }).then(function (response) { // At this point, Flask has printed our JSON
                                return response.text();
                              }).then(function (text) {

                              console.log('POST response: ');
                             // Should be 'OK' if everything was successful
                                    var radius_signal =  JSON.parse(text);
                                    console.log(radius_signal);
                                    //get the wifi name from the nav_name to get the radius data from signal on each robot 
                                    //Object.keys(radius_signal)[0]
                                    try{
                                        var real_radius = radius_signal[nav_name]['distance'] 
                                        console.log(real_radius);
                                        data_wifi_localization['radious'] = real_radius
                                    }
                                    catch{
                                            alert("Device middleware was not generated into the hardware or middleware is offline please check")
                                    }                                
                           });
                            
                            r = data_wifi_localization['radious']
                            data_wifi_localization['text_pos'] = {'x':data_pos['x'],'y':data_pos['y'],'z':data_pos['z']}                               
                            //Add the dynamic loop of the RSSI signal  
                            var geometrys = new THREE.SphereGeometry(r, 32, 32, -Math.PI/2, Math.PI);
                            var materials = new THREE.MeshBasicMaterial({color: settings['dome_color']});
                            var wireframe = new THREE.WireframeGeometry(geometrys)
                            var domes_wifi = new THREE.LineSegments(wireframe,materials);                               
                            //Create a mesh using the geometry and material
                            //var domes_wifi = new THREE.Mesh(geometrys, materials);
                            //Text label and the position data text mesh 
                            
                            //Add the axis of the signal position 
                            var axesGroupSc = new THREE.Group();
                            var xAxisSc = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                               new THREE.LineBasicMaterial({ color: 0xff0000 })
                            );
                            var  yAxisSc = new THREE.Line(
                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                             new THREE.LineBasicMaterial({ color: 0x00ff00 })
                            );
                            var zAxisSc = new THREE.Line(
                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                            );
                            if(control_logic_function['Axes_path'] == true){
                                   // Create an object to group the axes and add them to the scene
                                   
                                   axesGroupSc.add(xAxisSc, yAxisSc, zAxisSc);
                                   axesGroupSc.position.set(data_pos['x'],r+data_pos['y'],data_pos['z']);   //Get the real position request from the robot to display on the web 
                                   scene.add(axesGroupSc);    
                            }
                         
                            domes_wifi.position.set(data_pos['x'],data_pos['y'],h); // Add the  x,z,y 
                            // Add the dome to the scene
                            domes_wifi.rotation.z = 270*Math.PI/180
                            scene.add(domes_wifi);
                            // Adjust the opacity of the material 
                            materials.opacity = 0.2;
                            /*
                            var floader_dat = new THREE.FontLoader();
                            floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                            // Create the text geometry using the loaded font
                            //In this case text label will be using the name of the robot using in the project that upload into the website
                            var textGeometry_dome2 = new THREE.TextGeometry(String(nav_name)+' ==>('+String(data_wifi_localization['text_pos']['x'])+","+String(data_wifi_localization['text_pos']['y'])+","+String(data_wifi_localization['text_pos']['z'])+")", {
                                font: font,
                                size: 0.2,
                                height:0.2
                            });
                            // Create a mesh from the text geometry
                            var materials_label2 = new THREE.MeshBasicMaterial({color:settings['color_label']}); //Get the color from the label 
                            var textMesh_dome2 = new THREE.Mesh(textGeometry_dome2, materials_label2);*/

                            // Add the text mesh to the scene
                            if(len_wifi_comps >=3){
                                                                      console.log("Enable the wifi localization dynamic trilationcalculation algorithm "); //Enable the data append into th list of the list of the wifi mobile selection function and static setting of wifi 
                                                                      //if len >3 then add the wifi localization data into the access point data 
                                                                      console.log("Trigger the position control of the navigation system ")
                                                                      //Running the new position updated on the trilation calculation 
                                                                      //Add list of the distance of the data             
                                                                      var access_p =0; 
                                                                      for(access_p >=0;access_p <=len_wifi_comps-1;access_p++){
                                                                                           console.log("Checking the component access point data in the loop "); 
                                                                                           var type_navsep =  Object.keys(main_pos_signal[wi])
                                                                                           var navigation_com = Object.keys(main_pos_signal[wi][type_navsep]) 
                                                                                           var access_fixed_point=  main_pos_signal[wi][type_navsep][navigation_com]
                                                                                           console.log(access_point_pos) 
                                                                                           var x_ap = access_fixed_point['x']; 
                                                                                           var y_ap = access_fixed_point['y']; 
                                                                                           var z_ap = access_fixed_point['z'];
                                                                                           if(settings_mobile_signal[wi] != true){

                                                                                                    access_point_pos[wi] = [x_ap,y_ap,z_ap,r]; // Append the access point of each one update into the system  
                                                                                                    
                                                                                           }
                                                                                           if(settings_mobile_signal[wi] == true){
                                                                                                   access_local_trilation[wi] = [x_ap,y_ap,z_ap,r];

                                                                                           }
                                                                                        

                                                                     }                            
                                                                     console.log("Access_point key data ",access_point_pos); //Get the local access point 
                                                                     console.log("Dynamic accesspoint data ",access_local_trilation);  //Get the wifi access point 
                                                                     
                                                                     var updated_coordinate = triangulation_calculation_coordinate(access_point_pos,access_local_trilation); // Get the main post signal data of   
                                                                     console.log("Trilation calculation update data ", updated_coordinate); 
                                                                     // update the position here in the code for the RSSI signal data 
                                                                     // if the location of the data update is only 3D fixed the position then using default Y-axis from the setting 
                                                                     //The object to update is dome of wifi signal localization boundary 
                                                                     if(settngs_mobile_signal[wi] == true){
                                                                             domes_wifi.position.set(updated_coordinate[0],access_local_trilation[wi][1],updated_coordinate[1]); // Add the  x,z,y 
                                                                             axesGroupSc.position.set(updated_coordinate[0],r+access_local_trilation[wi][1],updated_coordinate[1]);
                                                                             textMesh_dome2.position.set(updated_coordinate[0],r+access_local_trilation[wi][1]+1,updated_coordinate[1]);
                                                                     }
                                                                     if(settings_mobile_signal[wi] != true){
                                                                             domes_wifi.position.set(updated_coordinate[0],access_point_pos[wi][1],updated_coordinate[1]); // Add the  x,z,y 
                                                                             axesGroupSc.position.set(updated_coordinate[0],r+access_point_pos[wi][1],updated_coordinate[1])
                                                                             textMesh_dome2.position.set(updated_coordinate[0],r+access_point_pos[wi][1]+1,updated_coordinate[1]);
                                                                     }
                                                                      

                                                        }
                                                        
                                                        if(len_wifi_comps <3 || len_wifi_comps >=3){
                                                                    console.log("Deactivate the mobile dynamic trilation calculation");
                                                                                                                       
                                                                    textMesh_dome2.position.set(data_wifi_localization['text_pos']['x'],r+data_wifi_localization['text_pos']['y']+1,data_wifi_localization['text_pos']['z'])
                                                        }
                                                       scene.add(textMesh_dome2);
                            
                           // });                                                        
                        }
          
                    }
                   if(camera_navigationmap != {}){
                                  console.log("Camera_navigation system ")
                                  for(var cam_wi in camera_navigationmap){

                                            console.log("Camera navigation data ",cam_wi,camera_navigationmap[cam_wi])            
                                            //Add the camera 3d model function into the scene 
                                            var data_cam_main = camera_navigationmap[cam_wi] 
                                            var data_cam_type = Object.keys(data_cam_main)[0]
                                            var data_cam_com = Object.keys(camera_navigationmap[cam_wi][data_cam_type])[0]
                                            var cam_characteristic = camera_navigationmap[cam_wi][data_cam_type][data_cam_com] 
                                            console.log(cam_characteristic); 
                                            var floader_dat = new THREE.FontLoader();
                                            floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                                            var axesGroupSr = new THREE.Group();
                            var xAxisSr = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                               new THREE.LineBasicMaterial({ color: 0xff0000 })
                            );
                            var  yAxisSr = new THREE.Line(
                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                             new THREE.LineBasicMaterial({ color: 0x00ff00 })
                            );
                            var zAxisSr = new THREE.Line(
                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                            );
                            if(control_logic_function['Axes_path'] == true){
                                   // Create an object to group the axes and add them to the scene
                                   
                                   axesGroupSr.add(xAxisSr, yAxisSr, zAxisSr);
                                   axesGroupSr.position.set(cam_characteristic['x'],cam_characteristic['y']+0.5,cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                   scene.add(axesGroupSr);    
                            }
                            
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                var textGeometry_dome_c = new THREE.TextGeometry(String(cam_wi)+' ==>('+String(cam_characteristic['x'])+","+String(cam_characteristic['y'])+","+String(cam_characteristic['z'])+")", {
                                font: font,
                                size: 0.2,
                                height:0.2
                            });
                // Create a mesh from the text geometry
                var materials_label_c = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                var textMesh_dome_c = new THREE.Mesh(textGeometry_dome_c, materials_label_c);
                // Add the text mesh to the scene
                textMesh_dome_c.position.set(cam_characteristic['x'],cam_characteristic['y']+1,cam_characteristic['z'])
                scene.add(textMesh_dome_c);
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //Get the data fetching real-time data of the QR code camera 
                fetch('/camera_nav_stream', {

                      // Declare what type of data we're sending  
                      headers: {
                           'Content-Type': 'application/json'
                    },

                  // Specify the method
                 method: 'POST',

                // A JSON payload 
               body: JSON.stringify({
                         "email":email_data 
               })
              }).then(function (response) { // At this point, Flask has printed our JSON
                   return response.text();
             }).then(function (text) {

                   console.log('POST response: ');
                   // Should be 'OK' if everything was successful
                   var real_cam_position = JSON.parse(text);
                   console.log("Get the real_time_cam",real_cam_position);
                   var posi_cam_real = real_cam_position[project_names]; //Get the position of the 
                   console.log("Get camera_QR code tracking position",posi_cam_real);
                   //Select the camera index data from the generated code 
                   // /gen_local_request 
                   fetch('/gen_local_request', {
                      // Declare what type of data we're sending
                      headers: {
                        'Content-Type': 'application/json'
                   },
                  // Specify the method
                  method: 'POST',
                  // A JSON payload
                  body: JSON.stringify({
                            "email": email_data 
                  })
                  }).then(function (response) { // At this point, Flask has printed our JSON
                  return response.text();
                 }).then(function (text) {
                                console.log('POST response: ');
                               // Should be 'OK' if everything was successful
                               var cam_data_json = JSON.parse(text); //Get the data of the navigation component to get the camera index 
                               console.log("Get the component json",cam_data_json); //Get the local json gen_nav 
                               var host_name = Object.keys(cam_data_json["navigation_payload"]) 
                               var project_name = Object.keys(cam_data_json["navigation_payload"][host_name]) //Get the project name of the  navigation system 
                               var camera_info_dat = cam_data_json["navigation_payload"][host_name][project_name][cam_wi]  //Get the camera data payload from the camera name input function 
                               console.log("Get the camera information ",camera_info_dat['camera_index']); //Get the camera data payload information to extract the camera index data 
                               console.log("Get the cameera position ",posi_cam_real[camera_info_dat['camera_index']]); //Get the camera index data                                                              
                               var position_cam_qr = posi_cam_real[camera_info_dat['camera_index']]; 
                        console.log("Camera_position_swarm_mode ",cam_characteristic['view_pos']); 
                        //Get the selected image position data 
                        if(cam_characteristic['view_pos'] == "Top"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],1,-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                        

                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],1,-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'])
                                            scene.add(textMesh_cam);
                                             }
                                             if(cam_characteristic['view_pos'] == "Side"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z'],1);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'],1)
                                            scene.add(textMesh_cam);
                                             
                                        }   
                           
                 
                    });

            
             });

                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            });
                    
                //Tract the current position that camera detect 
    }

}
//Lidar sensor in sync mode function to get the position of the lidar in the real-time 
if (lidar_navigationmap !={}){
                                  console.log("Lidar navigation function for the point cloud map of lidar mapping"); 
                             
                                  for(var lidar_dat in lidar_navigationmap){
                                                   console.log("Lidar navigation data ",lidar_dat,lidar_navigationmap[lidar_dat]); 
                                                   var lidar_dat_main = lidar_navigationmap[lidar_dat]; // Get the lidar main data 
                                                   var lidar_dat_type = Object.keys(lidar_navigationmap[lidar_dat])[0] //Get the lidar data type 
                                                   var lidar_dat_com = Object.keys(lidar_navigationmap[lidar_dat][lidar_dat_type])[0] 
                                                   var lidar_characteristic = lidar_navigationmap[lidar_dat][lidar_dat_type][lidar_dat_com]  
                                                   console.log("Get the lidar charateristic ",lidar_characteristic); 
                                                   
                                                   //Append the position of the 3D model of the lidar data and label text of the lidar position 
                                                       
                                                 if(lidar_characteristic['lidar_state'] == true) 
                                                           {
                                                                console.log("Data lidar generator ")  
                                                               //Get the position of the axes here 
                                                               //Get the posion  
                                                               //request the lidar back-end to process the point cloud data of the lidar mapping visualization on the roboreactor navigaiton system 
                                                               fetch('/lidar_res_request', {

                                                                 // Declare what type of data we're sending   
                                                                 headers: {
                                                                     'Content-Type': 'application/json'
                                                                 },
                                                                // Specify the method
                                                                method: 'POST',
                                                                // A JSON payload  
                                                                body: JSON.stringify({
                                                               "email":email_data  // Get the lidar name from the list of the loop to collect the streaming lidar data  
                                                               })
                                                               }).then(function (response) { // At this point, Flask has printed our JSON
                                                                return response.text();
                                                               }).then(function (text) {
                                                                    console.log('POST response: ');
                                                                    var lidar_data_stream = JSON.parse(text); //Data stream of the lidar from the back-end request
                                                                    console.log("Get the lidar data",lidar_data_stream[email_data]); // Get the data from the data streamer function 
                                                                    var lidar_embed = lidar_data_stream[email_data]; 
                                                                    //Load the axes of the lidar position 
                                                                    //console.log("Get the real-time postion of the lidar axes function",lidar_data_stream[lidar_dat]) // This will request from the hardware sync function of the odometry position 
                                                                    
                                                                    //Get the raw data of the lidar data from the function of the code
                                                                    //Get lidar plot data using range and angle of the plot funcition 
                                                                    var lidar_index = 0; 
                                                                    console.log("Lidar data internal ",lidar_embed); // Get the lidar embed  
                                                                    var list_lidar = Object.keys(lidar_embed); 
                                                                    console.log("Get the list lidar components",list_lidar);                                                                      
                                                                    console.log("list_lidar_components ",list_lidar); // Get the list lidar components function 
                                                                    for(lidar_index >0;lidar_index <= list_lidar.length-1;lidar_index++){
                                                                                      var lidar_names = list_lidar[lidar_index]
                                                                                      var lidar_streaming = lidar_embed[list_lidar[lidar_index]]; 
                                                                                      
                                                                                      var ranges_lidar = lidar_streaming['Ranges'] 
                                                                                      var angles_lidar = lidar_streaming['Angles'] 
                                                                                      console.log("Lidar parameters ",ranges_lidar,angles_lidar);  
                                                                                      var index_range = 0; 
                                                                                      for(index_range > 0;index_range < ranges_lidar.length-1 ;index_range++){
                                                                                                 var radians = angles_lidar[index_range] *(Math.PI / 180);

                                                                                                 var x_polar_c = (ranges_lidar[index_range]/100)*Math.cos(radians); // Get the index range plot data for the x axis 
                                                                                                 var y_polar_c = (ranges_lidar[index_range]/100)*Math.sin(radians); // Get the index range plot data for the y axis                                         
                                                                                                 var z_polar_c = 1 
                                                                                                 console.log("Coordinate_polar",x_polar,y_polar);   
                                                                                                 //Get the 3D data to visualize the data of the lidar dynamic mapping value 
                                                                                                 
                                                                                                 //lidar_array_pcd.push({x_polar,y_polar,z_polar}); // Get the the data of the polar coordination 
                                                                                                 //console.log("Point cloud data array",lidar_array_pcd); // Get the polar coordination data of the pcd point cloud data 
                                                                                                 var pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                                                                                                 // Create a material for the point 
                                                                                                 var pointMaterial = new THREE.MeshBasicMaterial({ color: lidar_characteristic['lidar_pcd_color']}); // Set the color from the default setting in dynamic GUI 
                                                                                                 // Create a point mesh
                                                                                                 var point = new THREE.Mesh(pointGeometry, pointMaterial);
                                                                                                 //Get the lidar characteristic to running the default position of the lidar to be able to 
                                                                                                 var x_dat_polar_c = lidar_characteristic['x']; // Get the x_polar characteristic data 
                                                                                                 var y_dat_polar_c = lidar_characteristic['y']; // Get the y_polar characteristic data 
                                                                                                 var z_dat_polar_c = lidar_characteristic['z']; // Get the z_polar characteristic data 
                                                                                                 console.log("Default setting parameters data ", x_dat_polar_c,y_dat_polar_c,z_dat_polar_c); //Display the local data parameters 
                                                                                                 //Dynamic motion input sync from the hardware of odometry sensor will move the navigation component around with 3d models and move alongside with the navigation system 
                                                                                                 //Add Axis of the lidar position into the scene of the navigation system 
                                                                                                 var axesGroupSlc = new THREE.Group();
                                                                                                 var xAxisSlc = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                                                                      new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                                                                 );
                                                                                                 var  yAxisSlc= new THREE.Line(
                                                                                                  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                                                                  new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                                                                 );
                                                                                                 var zAxisSlc = new THREE.Line(
                                                                                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                                                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                                                                 );
                                                                                                 if(control_logic_function['Axes_path'] == true){
                                                                                                                    // Create an object to group the axes and add them to the scene
                                                                                                                    axesGroupSlc.add(xAxisSlc, yAxisSlc, zAxisSlc);
                                                                                                                    axesGroupSlc.position.set(lidar_characteristic['x'],lidar_characteristic['y']+0.5,lidar_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                                                                                    scene.add(axesGroupSlc);    
                                                                                                 }

                                                                                                 //Add the text label here in dynamic mode css2d
                                                                                                 //lidar_position_label["lidar_label"] = {'x':x_dat_polar,'y':y_dat_polar,'z':z_dat_polar}; 
                                                                                                 point.position.set(x_polar_c+x_dat_polar_c, y_dat_polar_c,y_polar_c+z_dat_polar_c); // Set the position of the point  // This position set will be added in the animation for the animation mode selection mode 
                                                                                                 scene.add(point);
                                                                                                
                                                                                            
                                                                                                                             
                                                                                       } 
                                                                }                                                                   
                                                                 
                                                                });   
                                                                       
                                                               //Load the 3D model of the label mesh data 
                                                               
                                                           }                                                           
                                                           if(lidar_characteristic['lidar_state'] == false){
                                                              //Lodar the axes of the lidar position 
                                                              //Lodar the 3D model of the label mesh data 

                                                           }

                                                             

                                                
                                                                   
                                 }
                             

                  }
                        }
                    
                        catch{

                             console.log("Error no hardware syncronize on the web");
                        }
                        

                        //dome_signal_rssi_radar() // Add the parameter of the dome into the system to cover the area of the beacon inside animation in real-time
                        // Running th for loop to add the dynamic realtime navigation dome into the scene 
                          
                        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                        scene.add(axesGroup);    
                        }                                            

                                      }); 
                                 }
                        catch{
                             console.log("Error hardware sync connection ")                            
                         }
                        

                       }

                       if(control_logic_function['swarm_mode'] == true){
                               console.log("Eanble Swarm mode function ")
                               //Open the swarm mode 
                fetch('/Navigation_mesh_swarm', {
                        // Declare what type of data we're sending
                        headers: {
                            'Content-Type': 'application/json'
                        },
                       // Specify the method
                      method: 'POST',
                      // A JSON payload
                      body: JSON.stringify({"email":email_data
                 })
               }).then(function (response) { // At this point, Flask has printed our JSON
               return response.text();
               }).then(function (text) {
                       
                           var mesh_swarm = JSON.parse(text);
                           //Get the mesh swarm feature to running the swarm of the robot in the loop  
                           console.log(mesh_swarm); //Get the data of the mesh swarm to running in the loop 
                           //Read the swarm bot name in user fleet robot        
                           var floader = new THREE.FontLoader();
                           floader.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                             for (var key in mesh_swarm) {
                                 if (mesh_swarm.hasOwnProperty(key)) {   
                                     var textMaterial = new THREE.MeshBasicMaterial({ color: control_logic_function[key]});  
                                     var motionData = mesh_swarm[key].motion_data;
                                     var position = new THREE.Vector3(motionData[0], motionData[1], motionData[2]);
                                     //var rotation = new THREE.Euler(THREE.MathUtils.degToRad(position_imu_data['AngleDegX']), THREE.MathUtils.degToRad(position_imu_data['AngleDegZ']), THREE.MathUtils.degToRad(position_imu_data['AngleDegY']), 'XYZ');
                                     var rotation = new THREE.Euler(THREE.MathUtils.degToRad(motionData[3]), THREE.MathUtils.degToRad(motionData[4]), THREE.MathUtils.degToRad(motionData[5]), 'XYZ');
                                     
                                     var textGeometry = new THREE.TextGeometry(key+" ==> ("+String(motionData[0]+","+String(motionData[1])+","+String(motionData[2])+")"), { font: font, size: 0.5, height: 0.1 });
                                     var textMesh = new THREE.Mesh(textGeometry, textMaterial);
                                     textMesh.position.copy(position);
                                     textMesh.rotation.copy(rotation);
                                     scene.add(textMesh);
                                     const xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                      new THREE.LineBasicMaterial({ color: 0xff0000 })
                                     );
                                     const yAxisS = new THREE.Line(
                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                     );
                                     const zAxisS = new THREE.Line(
                                        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                        new THREE.LineBasicMaterial({ color: 0x0000ff })
                                     );

                                     if(control_logic_function['Axes_path'] == true){
                                           // Create an object to group the axes and add them to the scene
                                           const axesGroupS = new THREE.Group();
                                           axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                           axesGroupS.position.set(motionData[0],motionData[1],motionData[2]);   //Get the real position request from the robot to display on the web 
                                           scene.add(axesGroupS);     
                                           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                           //These axis are going to use the data selectable from the  hardware angle to change the camera position data 

                                           axesGroupS.rotation.x = motionData[3]
                                           axesGroupS.rotation.y = motionData[4]
                                           axesGroupS.rotation.z = motionData[5]
                                           var x_polar = Math.cos(motionData[3])
                                           var y_polar = Math.sin(motionData[4]) 
                                           var r_polar = Math.sqrt(Math.pow(x_polar,2)+Math.pow(y_polar,2)); 
                                           var x_polar_ = r_polar*Math.sin(motionData[3])*Math.cos(motionData[4])
                                           var y_polar_ = r_polar*Math.sin(motionData[3])*Math.sin(motionData[4])
                                           var z_polar_ = r_polar*Math.cos(motionData[4])
                                           var cam_r_polar = Math.sqrt(Math.pow(randomIntX,2)+Math.pow(randomIntY,2)); 
                                           var cam_polar_angle_x  = Math.acos(x_polar/r_polar)
                                           var cam_polar_angle_y  = Math.asin(y_polar/r_polar)
                                             

                                           if(control_logic_function['fps_cam_logic'] == true){
                     
                                                         camera.position.set(motionData[0],motionData[1],motionData[2]);
                   
                                           }
                                           if(control_logic_function['orbit_cam_logic'] == true){
                                                        //Control the angle (x,y,z)
                                                        if(control_logic_function['follow_cam'] == false){

                                                                      camera.rotation.x =  -motionData[3]*Math.PI/180 //  row 
                                                                      camera.rotation.y =  motionData[4]*Math.PI/180  //  yaw
                                                                      camera.rotation.z =  motionData[5]*Math.PI/180  //  pitch
                                                        }
                                                        if(control_logic_function['follow_cam'] == true){
                                                                      camera.rotation.x = cam_polar_angle_x*Math.PI/180 //  row 
                                                                      camera.rotation.y = cam_polar_angle_y*Math.PI/180  //  yaw
                                                                      camera.rotation.z = motionData[5]*Math.PI/180  //  pitch
                                           
                                                        }
                                                        
                                          }

                                          var material2 = new THREE.LineBasicMaterial({color: control_logic_function[key+"_pathc"]}); // Red color
                                          //Calculate the position from the IMU data to draw the line and move the point cloud into the difference position 
                                          points_list_swarm[key] = []  
                                          points_list_swarm[key].push(new THREE.Vector3(0,0,0))

                                          points_list_swarm[key].push(new THREE.Vector3(motionData[0],motionData[1],motionData[2])); 
                                          console.log("Move_path_swarm_"+key,points_list_swarm[key]);
                            try{
                               var curve_swarm = new THREE.CatmullRomCurve3(points_list_swarm[key]);
                                // Define the geometry of the line using the curve
                               var geometry_swarm = new THREE.Geometry();
                               geometry_swarm.vertices = curve_swarm.getPoints(50); // Get 50 points along the curve
                               // Create the line object
                               var line_swarm = new THREE.Line(geometry_swarm, material2);
                               scene.add(line_swarm);
                           }
                           catch{
                                    console.log("Path process error")
                          }
                          if(main_pos_signal !={}){
                           //Running the for loop 
                          for(var wi in main_pos_signal){
                                   console.log("Navigation components ",wi); //Get the data pos from each components 
                                   var data_p= Object.keys(main_pos_signal) // Get the list of the navigation components  
                                   console.log("Check_pos_data ",main_pos_signal[wi]);   

                                   console.log(wi)
                                   var nav_name =  wi //Object.keys(main_pos_signal)[0] // Input the number of the nav name component to running inside the loop to generate connection code 
                                   console.log("Name devices ", nav_name);
                                   var nav_type = main_pos_signal[nav_name]
                                   console.log(nav_type); 
                                   var data_nav = Object.keys(nav_type)[0];
                                   console.log(data_nav); 
                                   var data_nav_con = nav_type[data_nav]
                                   var data_com = Object.keys(data_nav_con)[0];
                                   console.log(data_com);
                                   var data_pos = main_pos_signal[nav_name][data_nav][data_com]
   
                                    console.log("Generate the function from the json main position path ")

                          
                            var h = data_pos['z']; 
                            //Fetch the data of the signal strange convert from the RSSI fetching hardware 
                            var r = 0; 
                            
                            fetch('/rssi_beacon_hw', {
                                  // Declare what type of data we're sending
                                  headers: {
                                       'Content-Type': 'application/json'
                                  },
                                 // Specify the method
                                 method: 'POST',
                                 // A JSON payload
                                 body: JSON.stringify({
                                         "email": email_data,"wifi_device":nav_name     //Sending the marker wifi name to the back-end to get the feedback position from the robot hardware 
                                })
                                }).then(function (response) { // At this point, Flask has printed our JSON
                                return response.text();
                              }).then(function (text) {

                              console.log('POST response: ');
                             // Should be 'OK' if everything was successful
                                    var radius_signal =  JSON.parse(text);
                                    console.log(radius_signal);
                                    //get the wifi name from the nav_name to get the radius data from signal on each robot 
                                    //Object.keys(radius_signal)[0]
                                    try{
                                        var real_radius = radius_signal[nav_name]['distance'] 
                                        console.log(real_radius);
                                        data_wifi_localization['radious'] = real_radius
                                    }
                                    catch{
                                            alert("Device middleware was not generated into the hardware or middleware is offline please check")
                                    }                                
                           });
                            
                            r = data_wifi_localization['radious']
                            data_wifi_localization['text_pos'] = {'x':data_pos['x'],'y':data_pos['y'],'z':data_pos['z']}                               
                            //Add the dynamic loop of the RSSI signal  
                            var geometrys = new THREE.SphereGeometry(r, 32, 32, -Math.PI/2, Math.PI);
                            var materials = new THREE.MeshBasicMaterial({color: settings['dome_color']});
                            var wireframe = new THREE.WireframeGeometry(geometrys)
                            var domes_wifi = new THREE.LineSegments(wireframe,materials);                               
                            //Create a mesh using the geometry and material
                            //var domes_wifi = new THREE.Mesh(geometrys, materials);
                            //Text label and the position data text mesh 
                            
                            //Add the axis of the signal position 
                            var axesGroupSc = new THREE.Group();
                            var xAxisSc = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                               new THREE.LineBasicMaterial({ color: 0xff0000 })
                            );
                            var  yAxisSc = new THREE.Line(
                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                             new THREE.LineBasicMaterial({ color: 0x00ff00 })
                            );
                            var zAxisSc = new THREE.Line(
                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                            );
                            if(control_logic_function['Axes_path'] == true){
                                   // Create an object to group the axes and add them to the scene
                                   
                                   axesGroupSc.add(xAxisSc, yAxisSc, zAxisSc);
                                   axesGroupSc.position.set(data_pos['x'],r+data_pos['y'],data_pos['z']);   //Get the real position request from the robot to display on the web 
                                   scene.add(axesGroupSc);    
                            }
                         
                            domes_wifi.position.set(data_pos['x'],data_pos['y'],h); // Add the  x,z,y 
                            // Add the dome to the scene
                            domes_wifi.rotation.z = 270*Math.PI/180
                            scene.add(domes_wifi);
                            // Adjust the opacity of the material 
                            materials.opacity = 0.2;
                            var floader_dat = new THREE.FontLoader();
                            floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                            // Create the text geometry using the loaded font
                            //In this case text label will be using the name of the robot using in the project that upload into the website
                            var textGeometry_dome2 = new THREE.TextGeometry(String(nav_name)+' ==>('+String(data_wifi_localization['text_pos']['x'])+","+String(data_wifi_localization['text_pos']['y'])+","+String(data_wifi_localization['text_pos']['z'])+")", {
                                font: font,
                                size: 0.2,
                                height:0.2
                            });
                            // Create a mesh from the text geometry
                            var materials_label2 = new THREE.MeshBasicMaterial({color:settings['color_label']}); //Get the color from the label 
                            var textMesh_dome2 = new THREE.Mesh(textGeometry_dome2, materials_label2);
                            // Add the text mesh to the scene
                            textMesh_dome2.position.set(data_wifi_localization['text_pos']['x'],r+data_wifi_localization['text_pos']['y']+1,data_wifi_localization['text_pos']['z'])
                            scene.add(textMesh_dome2);
                            
                            });                                                        
                        }
          
                    }
                    if (lidar_navigationmap !={}){
                                  console.log("Lidar navigation function for the point cloud map of lidar mapping"); 
                             
                                  for(var lidar_dat in lidar_navigationmap){
                                                   console.log("Lidar navigation data ",lidar_dat,lidar_navigationmap[lidar_dat]); 
                                                   var lidar_dat_main = lidar_navigationmap[lidar_dat]; // Get the lidar main data 
                                                   var lidar_dat_type = Object.keys(lidar_navigationmap[lidar_dat])[0] //Get the lidar data type 
                                                   var lidar_dat_com = Object.keys(lidar_navigationmap[lidar_dat][lidar_dat_type])[0] 
                                                   var lidar_characteristic = lidar_navigationmap[lidar_dat][lidar_dat_type][lidar_dat_com]  
                                                   console.log("Get the lidar charateristic ",lidar_characteristic); 
                                                   
                                                   //Append the position of the 3D model of the lidar data and label text of the lidar position 
                                                       
                                                 if(lidar_characteristic['lidar_state'] == true) 
                                                           {
                                                                console.log("Data lidar generator ")  
                                                               //Get the position of the axes here 
                                                               //Get the posion  
                                                               //request the lidar back-end to process the point cloud data of the lidar mapping visualization on the roboreactor navigaiton system 
                                                               fetch('/lidar_res_request', {

                                                                 // Declare what type of data we're sending   
                                                                 headers: {
                                                                     'Content-Type': 'application/json'
                                                                 },
                                                                // Specify the method
                                                                method: 'POST',
                                                                // A JSON payload  
                                                                body: JSON.stringify({
                                                               "email":email_data  // Get the lidar name from the list of the loop to collect the streaming lidar data  
                                                               })
                                                               }).then(function (response) { // At this point, Flask has printed our JSON
                                                                return response.text();
                                                               }).then(function (text) {
                                                                    console.log('POST response: ');
                                                                    var lidar_data_stream = JSON.parse(text); //Data stream of the lidar from the back-end request
                                                                    console.log("Get the lidar data",lidar_data_stream[email_data]); // Get the data from the data streamer function 
                                                                    var lidar_embed = lidar_data_stream[email_data]; 
                                                                    //Load the axes of the lidar position 
                                                                    //console.log("Get the real-time postion of the lidar axes function",lidar_data_stream[lidar_dat]) // This will request from the hardware sync function of the odometry position 
                                                                    
                                                                    //Get the raw data of the lidar data from the function of the code
                                                                    //Get lidar plot data using range and angle of the plot funcition 
                                                                    var lidar_index = 0; 
                                                                    console.log("Lidar data internal ",lidar_embed); // Get the lidar embed  
                                                                    var list_lidar = Object.keys(lidar_embed); 
                                                                    console.log("Get the list lidar components",list_lidar);                                                                      
                                                                    console.log("list_lidar_components ",list_lidar); // Get the list lidar components function 
                                                                    for(lidar_index >0;lidar_index <= list_lidar.length-1;lidar_index++){
                                                                                      var lidar_names = list_lidar[lidar_index]
                                                                                      var lidar_streaming = lidar_embed[list_lidar[lidar_index]]; 
                                                                                      
                                                                                      var ranges_lidar = lidar_streaming['Ranges'] 
                                                                                      var angles_lidar = lidar_streaming['Angles'] 
                                                                                      console.log("Lidar parameters ",ranges_lidar,angles_lidar);  
                                                                                      var index_range = 0; 
                                                                                      for(index_range > 0;index_range < ranges_lidar.length-1 ;index_range++){
                                                                                                 var radians = angles_lidar[index_range] *(Math.PI / 180);

                                                                                                 var x_polar_r = (ranges_lidar[index_range]/100)*Math.cos(radians); // Get the index range plot data for the x axis 
                                                                                                 var y_polar_r = (ranges_lidar[index_range]/100)*Math.sin(radians); // Get the index range plot data for the y axis                                         
                                                                                                 var z_polar_r = 1 
                                                                                                 console.log("Coordinate_polar",x_polar,y_polar);   
                                                                                                 //Get the 3D data to visualize the data of the lidar dynamic mapping value 
                                                                                                 
                                                                                                 //lidar_array_pcd.push({x_polar,y_polar,z_polar}); // Get the the data of the polar coordination 
                                                                                                 //console.log("Point cloud data array",lidar_array_pcd); // Get the polar coordination data of the pcd point cloud data 
                                                                                                 var pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                                                                                                 // Create a material for the point 
                                                                                                 var pointMaterial = new THREE.MeshBasicMaterial({ color: lidar_characteristic['lidar_pcd_color']}); // Set the color from the default setting in dynamic GUI 
                                                                                                 // Create a point mesh
                                                                                                 var point = new THREE.Mesh(pointGeometry, pointMaterial);
                                                                                                 //Get the lidar characteristic to running the default position of the lidar to be able to 
                                                                                                 var x_dat_polar_r = lidar_characteristic['x']; // Get the x_polar characteristic data 
                                                                                                 var y_dat_polar_r = lidar_characteristic['y']; // Get the y_polar characteristic data 
                                                                                                 var z_dat_polar_r = lidar_characteristic['z']; // Get the z_polar characteristic data 
                                                                                                 console.log("Default setting parameters data ", x_dat_polar_r,y_dat_polar_r,z_dat_polar_r); //Display the local data parameters 
                                                                                                 //Dynamic motion input sync from the hardware of odometry sensor will move the navigation component around with 3d models and move alongside with the navigation system 
                                                                                                 //Add Axis of the lidar position into the scene of the navigation system 
                                                                                                 var axesGroupSlr = new THREE.Group();
                                                                                                 var xAxisSl_r = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                                                                      new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                                                                 );
                                                                                                 var  yAxisSl_r= new THREE.Line(
                                                                                                  new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                                                                  new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                                                                 );
                                                                                                 var zAxisSl_r = new THREE.Line(
                                                                                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                                                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                                                                 );
                                                                                                 if(control_logic_function['Axes_path'] == true){
                                                                                                                    // Create an object to group the axes and add them to the scene
                                                                                                                    axesGroupSlr.add(xAxisSl_r, yAxisSl_r, zAxisSl_r);
                                                                                                                    //Using the real position from the request input this will be calculate with the default static position to get the new update coordinate 
                                                                                                                    axesGroupSlr.position.set(lidar_characteristic['x'],lidar_characteristic['y']+0.5,lidar_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                                                                                    scene.add(axesGroupSlr);    
                                                                                                 }

                                                                                                 //Add the text label here in dynamic mode css2d
                                                                                                 //lidar_position_label["lidar_label"] = {'x':x_dat_polar,'y':y_dat_polar,'z':z_dat_polar}; 
                                                                                                 point.position.set(x_polar_r+x_dat_polar_r, y_dat_polar_r,y_polar_r+z_dat_polar_r); // Set the position of the point  // This position set will be added in the animation for the animation mode selection mode 
                                                                                                 scene.add(point);
                                                                                                
                                                                                            
                                                                                                                             
                                                                                       } 
                                                                }                                                                   
                                                                 
                                                                });   
                                                                       
                                                               //Load the 3D model of the label mesh data 
                                                               
                                                           }                                                           
                                                           if(lidar_characteristic['lidar_state'] == false){
                                                              //Lodar the axes of the lidar position 
                                                              //Lodar the 3D model of the label mesh data 

                                                           }

                                                             

                                                
                                                                   
                                 }
                             

                  }
                   if(camera_navigationmap != {}){
                                  console.log("Camera_navigation system ")
                                  for(var cam_wi in camera_navigationmap){

                                            console.log("Camera navigation data ",cam_wi,camera_navigationmap[cam_wi])            
                                            //Add the camera 3d model function into the scene 
                                            var data_cam_main = camera_navigationmap[cam_wi] 
                                            var data_cam_type = Object.keys(data_cam_main)[0]
                                            var data_cam_com = Object.keys(camera_navigationmap[cam_wi][data_cam_type])[0]
                                            var cam_characteristic = camera_navigationmap[cam_wi][data_cam_type][data_cam_com] 
                                            console.log(cam_characteristic); 
                                            var floader_dat = new THREE.FontLoader();
                                            floader_dat.load('../static/fonts/helvetiker_regular.typeface.json', function(font) {
                                            var axesGroupSr = new THREE.Group();
                            var xAxisSr = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                               new THREE.LineBasicMaterial({ color: 0xff0000 })
                            );
                            var  yAxisSr = new THREE.Line(
                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                             new THREE.LineBasicMaterial({ color: 0x00ff00 })
                            );
                            var zAxisSr = new THREE.Line(
                                 new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                 new THREE.LineBasicMaterial({ color: 0x0000ff })
                            );
                            if(control_logic_function['Axes_path'] == true){
                                   // Create an object to group the axes and add them to the scene
                                   
                                   axesGroupSr.add(xAxisSr, yAxisSr, zAxisSr);
                                   axesGroupSr.position.set(cam_characteristic['x'],cam_characteristic['y']+0.5,cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                   scene.add(axesGroupSr);    
                            }
                            
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                var textGeometry_dome_c = new THREE.TextGeometry(String(cam_wi)+' ==>('+String(cam_characteristic['x'])+","+String(cam_characteristic['y'])+","+String(cam_characteristic['z'])+")", {
                                font: font,
                                size: 0.2,
                                height:0.2
                            });
                // Create a mesh from the text geometry
                var materials_label_c = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                var textMesh_dome_c = new THREE.Mesh(textGeometry_dome_c, materials_label_c);
                // Add the text mesh to the scene
                textMesh_dome_c.position.set(cam_characteristic['x'],cam_characteristic['y']+1,cam_characteristic['z'])
                scene.add(textMesh_dome_c);
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //Get the data fetching real-time data of the QR code camera 
                fetch('/camera_nav_stream', {

                      // Declare what type of data we're sending  
                      headers: {
                           'Content-Type': 'application/json'
                    },

                  // Specify the method
                 method: 'POST',

                // A JSON payload 
               body: JSON.stringify({
                         "email":email_data 
               })
              }).then(function (response) { // At this point, Flask has printed our JSON
                   return response.text();
             }).then(function (text) {

                   console.log('POST response: ');
                   // Should be 'OK' if everything was successful
                   var real_cam_position = JSON.parse(text);
                   console.log("Get the real_time_cam",real_cam_position);
                   var posi_cam_real = real_cam_position[project_names]; //Get the position of the 
                   console.log("Get camera_QR code tracking position",posi_cam_real);
                   //Select the camera index data from the generated code 
                   // /gen_local_request 
                   fetch('/gen_local_request', {
                      // Declare what type of data we're sending
                      headers: {
                        'Content-Type': 'application/json'
                   },
                  // Specify the method
                  method: 'POST',
                  // A JSON payload
                  body: JSON.stringify({
                            "email": email_data 
                  })
                  }).then(function (response) { // At this point, Flask has printed our JSON
                  return response.text();
                 }).then(function (text) {
                                console.log('POST response: ');
                               // Should be 'OK' if everything was successful
                               var cam_data_json = JSON.parse(text); //Get the data of the navigation component to get the camera index 
                               console.log("Get the component json",cam_data_json); //Get the local json gen_nav 
                               var host_name = Object.keys(cam_data_json["navigation_payload"]) 
                               var project_name = Object.keys(cam_data_json["navigation_payload"][host_name]) //Get the project name of the  navigation system 
                               var camera_info_dat = cam_data_json["navigation_payload"][host_name][project_name][cam_wi]  //Get the camera data payload from the camera name input function 
                               console.log("Get the camera information ",camera_info_dat['camera_index']); //Get the camera data payload information to extract the camera index data 
                               console.log("Get the cameera position ",posi_cam_real[camera_info_dat['camera_index']]); //Get the camera index data                                                              
                               var position_cam_qr = posi_cam_real[camera_info_dat['camera_index']]; 
                               console.log("Camera_position_swarm_mode ",cam_characteristic['view_pos']); 
                        //Get the selected image position data 
                        if(cam_characteristic['view_pos'] == "Top"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],1,-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z']);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                        

                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],1,-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'])
                                            scene.add(textMesh_cam);
                                            }
                                            if(cam_characteristic['view_pos'] == "Side"){ 
                                                        var axesGroupS = new THREE.Group();
                                                        var xAxisS = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]),
                                                           new THREE.LineBasicMaterial({ color: 0xff0000 })
                                                        );
                                                        var  yAxisS = new THREE.Line(
                                                         new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]),
                                                         new THREE.LineBasicMaterial({ color: 0x00ff00 })
                                                        );
                                                        var zAxisS = new THREE.Line(
                                                             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]),
                                                             new THREE.LineBasicMaterial({ color: 0x0000ff })
                                                        );
                                                        if(control_logic_function['Axes_path'] == true){
                                                               // Create an object to group the axes and add them to the scene
                                                               //Top scene 
                                                               axesGroupS.add(xAxisS, yAxisS, zAxisS);
                                                               axesGroupS.position.set(((position_cam_qr['X']/parseFloat(cam_characteristic['cam_px']))*parseFloat(cam_characteristic['area_x']))+cam_characteristic['x'],-((position_cam_qr['Y']/parseFloat(cam_characteristic['cam_py']))*parseFloat(cam_characteristic['area_y']))+cam_characteristic['z'],1);   //Get the real position request from the robot to display on the web 
                                                               scene.add(axesGroupS);    
                                                        
                                                        }
                                                        
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                            var textGeometry_cam = new THREE.TextGeometry(String(position_cam_qr['message'])+' ==>('+String(position_cam_qr['X'])+","+String(1)+","+String(position_cam_qr['Y'])+")", {
                                                            font: font,
                                                            size: 0.2,
                                                            height:0.2
                                                        });
                                            // Create a mesh from the text geometry
                                            var materials_label_1 = new THREE.MeshBasicMaterial({color:settings['camera_text_color']}); //Get the color from the label 
                                            var textMesh_cam = new THREE.Mesh(textGeometry_cam, materials_label_1);
                                            
                                            // Add the text mesh to the scene
                                            textMesh_cam.position.set(((position_cam_qr['X']/(cam_characteristic["cam_px"]))*cam_characteristic["area_x"])+cam_characteristic['x'],-((position_cam_qr['Y']/(cam_characteristic["cam_py"]))*cam_characteristic["area_y"])+cam_characteristic['z'],1)
                                            scene.add(textMesh_cam);
                                             
                                        }   
                           
                 
                    });

            
             });

                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            });
                    
                //Tract the current position that camera detect 
    }

}
                                        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

                                     }

                              }
                             }              
                     });  
                        
                      
                 });

             }
                    
                       render();
                       
                                   
                      
                         
            
              setTimeout(infiniteLoop,560);
            }
        
            // Call the infinite loop function to start the loop
            
            
            infiniteLoop();
            //animation();          
      function label_controldata(randomIntX,randomIntY,randomIntZ){
                          const geometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
                          const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                          var cube = new THREE.Mesh(geometry, material);
                          cube.position.set(randomIntX,randomIntY,randomIntZ);
                          scene.add(cube);
                             //label css test and update realtime 
                           var labelDiv = document.createElement('div');
                           var namecut_length = String(current_robot["current_robot"])+'_'+"("+String(parseInt(randomIntX))+","+String(parseInt(randomIntY))+","+String(parseInt(randomIntZ))+")"
                           var construct_namecut = namecut_length  //filename.split(namecut_length)[0];
                           labelDiv.className = 'label';
                           labelDiv.textContent = construct_namecut;
                           var label = new CSS2DObject(labelDiv);
                           // Function to update label position
                           function updateLabelPosition() {
                             const box = new THREE.Box3().setFromObject(cube);
                             const center = new THREE.Vector3();
                             box.getCenter(center);
                            // Calculate the offset from the model's position to its center
                            const offset = center.sub(cube.position);
                            // Set the label position to the center of the model
                            label.position.copy(offset);
                      
                             }
                            updateLabelPosition();
                            cube.add(label); 
      }
        // Call the loopCounter function to start the loop
        //loopCounter(0, 1000, 1, 1000);
			window.addEventListener( 'resize', onWindowResize );
            function onWindowResize() {

                   camera.aspect = window.innerWidth / window.innerHeight;
                   camera.updateProjectionMatrix();

                   renderer.setSize( window.innerWidth, window.innerHeight );
                   labelRenderer.setSize(window.innerWidth, window.innerHeight);
                   render();
                   
            }
            function render() {

                   renderer.render( scene, camera );
                   labelRenderer.render(scene, camera);
                  
            }
            function notify_data(status,text){
        toastr.options = {
             "closeButton": true,
             "newestOnTop": false,
             "progressBar": true,
             "positionClass": "toast-top-right",
             "preventDuplicates": false,
             "onclick": null,
             "showDuration": "300",
             "hideDuration": "1000",
             "timeOut": "5000",
             "extendedTimeOut": "1000",
             "showEasing": "swing",
             "hideEasing": "linear",
             "showMethod": "fadeIn",
            "hideMethod": "fadeOut"
           }
           if(status == 'success'){
              toastr.success(text); // if status success 
           }
           if(status != 'success'){
              toastr.warning(text); 
           }
            
  };
		</script>
        </div>
	</body>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KGJLJB0CMY">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KGJLJB0CMY');
</script>
</html>
